<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMHKv2 Web</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            color: #333;
        }

        .sidebar {
            width: 200px;
            position: fixed;
            left: 0;
            top: 0;
            background-color: #404040;
            height: 100vh;
            padding: 0;
            box-sizing: border-box;
            transition: width 0.3s ease, left 0.3s ease;
            font-family: 'Microsoft YaHei', '微软雅黑', 'SimHei', sans-serif;
            z-index: 999;
        }

        .sidebar.collapsed {
            width: 0;
            overflow: hidden;
        }

        .sidebar img {
            width: 100%;
            height: auto;
            display: block;
        }

        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar li {
            border-bottom: 1px solid white;
        }

        .sidebar a {
            display: block;
            padding: 15px;
            text-decoration: none;
            color: #ffffff;
            font-weight: bold;
        }

        .sidebar a:hover {
            background-color: #555555;
        }

        .toggle-btn {
            position: fixed;
            left: 200px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            z-index: 1000;
            transition: left 0.3s ease;
        }

        .toggle-btn::before {
            content: '';
            position: absolute;
            left: 0px;
            top: 50%;
            transform: translateY(-50%);
            width: 15px;
            height: 60px;
            background-color: #404040;
            clip-path: polygon(10% 0%, 100% 25%, 100% 75%, 10% 100%);
        }

        .toggle-btn::after {
            content: '';
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%) rotate(180deg);
            width: 0;
            height: 0;
            border-left: 5px solid #d3d3d3;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            transition: transform 0.3s ease;
        }

        .toggle-btn:hover::before {
            background-color: #bfbfbf;
        }

        .sidebar.collapsed~.toggle-btn {
            left: 0;
        }

        .sidebar.collapsed~.toggle-btn::after {
            transform: translateY(-50%);
        }

        .content {
            margin-left: 230px;
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        .content.expanded {
            margin-left: 30px;
        }

        .page {
            display: none;
        }

        .active {
            display: block;
        }

        /* 首頁樣式 */
        .homepage-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #000;
        }

        .homepage-subtitle {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #000;
        }

        /* 按鈕樣式 */
        .button-section {
            margin-bottom: 40px;
        }

        .connect-btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            color: white;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-family: 'SimHei', '黑體', sans-serif;
        }

        .connect-btn.connected {
            background-color: #dc3545;
        }

        .connect-btn.disconnected {
            background-color: #007bff;
        }

        .connect-btn:hover {
            opacity: 0.9;
        }

        /* 傳感器監控樣式 */
        .sensor-section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            color: #000;
        }

        .section-title::before {
            content: '';
            width: 12px;
            height: 12px;
            background-color: #000;
            margin-right: 10px;
        }

        .sensor-charts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .chart-container {
            background-color: #f0f0f0;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .chart-wrapper {
            position: relative;
            height: 250px;
        }

        /* GPIO 狀態樣式 */
        .gpio-section {
            margin-bottom: 40px;
        }

        .gpio-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .gpio-item {
            background-color: #f9f9f9;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .gpio-item-info {
            flex: 1;
        }

        .gpio-item-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .gpio-item-type {
            font-size: 12px;
            color: #666;
        }

        .gpio-item-value {
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: right;
        }

        .no-gpio {
            color: #999;
            font-style: italic;
            padding: 15px;
        }

        /* 串口日志样式 */
        .serial-log-section {
            margin-bottom: 40px;
        }

        .log-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .log-controls button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .log-controls button:hover {
            background-color: #0056b3;
        }

        .log-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .log-display {
            background-color: #1e1e1e;
            color: #00ff00;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #444;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .log-entry {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        .log-entry.send {
            color: #ffaa00;
        }

        .log-entry.receive {
            color: #00ff00;
        }

        .log-entry.error {
            color: #ff0000;
        }

        .log-entry.system {
            color: #aaaaaa;
        }

        .log-timestamp {
            color: #666666;
            margin-right: 8px;
        }

        .no-log {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 40px 15px;
        }

        /* 傳感器配置頁面樣式 */
        .sensor-config-section {
            margin-bottom: 30px;
        }

        .sensor-config-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn-add {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-add:hover {
            background-color: #0056b3;
        }

        .btn-delete {
            background-color: #dc3545;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-delete:hover:not(:disabled) {
            background-color: #c82333;
        }

        .btn-delete:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-delete-row {
            background-color: #dc3545;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-delete-row:hover {
            background-color: #c82333;
        }

        /* 傳感器列表樣式 */
        .sensor-list-container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #ddd;
        }

        .sensor-list-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'SimHei', '黑體', sans-serif;
        }

        .sensor-list-table thead {
            background-color: #f0f0f0;
            border-bottom: 2px solid #ddd;
        }

        .sensor-list-table th {
            padding: 12px;
            text-align: left;
            font-weight: bold;
            color: #333;
        }

        .sensor-list-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }

        .sensor-list-table tbody tr:hover {
            background-color: #f5f5f5;
        }

        .sensor-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .no-sensor-message {
            text-align: center;
            padding: 30px;
            color: #999;
            font-style: italic;
        }

        /* 模態框樣式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            animation: fadeIn 0.3s ease;
        }

        .modal.show {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background-color: #ffffff;
            margin: 50px auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            box-sizing: border-box;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .required-mark {
            color: #dc3545;
            margin-left: 3px;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-confirm {
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-confirm:hover {
            background-color: #218838;
        }

        .btn-cancel {
            background-color: #6c757d;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-cancel:hover {
            background-color: #5a6268;
        }

        .error-message {
            color: #dc3545;
            font-size: 12px;
            margin-top: 3px;
        }

        .modal-status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            font-weight: 300;
            text-align: center;
            display: none;
        }

        .modal-status.show {
            display: block;
        }

        .modal-status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .modal-status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* 基本設置樣式 */
        .settings-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .settings-section h2 {
            color: #333;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .settings-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .settings-row:last-of-type {
            margin-bottom: 20px;
        }

        .settings-col {
            flex: 1;
        }

        /* 當只有一個列時 */
        .settings-row .settings-col:only-child {
            grid-column: 1;
        }

        /* 重置設置樣式 */
        .settings-reset-section {
            margin-top: 40px;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .settings-reset-section h2 {
            color: #333;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .reset-warning {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }

        .reset-warning p {
            margin: 0;
            font-size: 14px;
        }

        .btn-reset {
            background-color: #dc3545;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-reset:hover {
            background-color: #c82333;
        }

        .btn-reset:active {
            background-color: #bd2130;
        }

        /* GPIO 控制臺樣式 */
        .gpio-config-item {
            background-color: #f9f9f9;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .gpio-config-info {
            flex: 1;
        }

        .gpio-config-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .gpio-config-details {
            font-size: 12px;
            color: #666;
            display: flex;
            gap: 20px;
        }

        .gpio-config-status {
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: right;
        }

        /* GPIO 控制狀態表格樣式 */
        .gpio-control-container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #ddd;
        }

        .gpio-control-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'SimHei', '黑體', sans-serif;
        }

        .gpio-control-table thead {
            background-color: #f0f0f0;
            border-bottom: 2px solid #ddd;
        }

        .gpio-control-table th {
            padding: 12px;
            text-align: left;
            font-weight: bold;
            color: #333;
        }

        .gpio-control-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .gpio-control-table tbody tr:hover {
            background-color: #f5f5f5;
        }

        .no-gpio-message {
            text-align: center;
            color: #999;
            font-style: italic;
        }

        /* Digital 開關樣式 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            background-color: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .toggle-switch.on {
            background-color: #28a745;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.3s ease;
        }

        .toggle-switch.on::after {
            left: 28px;
        }

        /* Analog 滑塊樣式 */
        .analog-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .analog-slider {
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #ddd 0%, #ddd 100%);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .analog-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .analog-slider::-webkit-slider-thumb:hover {
            background: #0056b3;
        }

        .analog-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s ease;
        }

        .analog-slider::-moz-range-thumb:hover {
            background: #0056b3;
        }

        .analog-value {
            min-width: 40px;
            font-weight: bold;
            color: #000;
            font-size: 14px;
        }

        /* GPIO 操作欄樣式 */
        .gpio-action-cell {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-gpio-confirm {
            background-color: #007bff;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }

        .btn-gpio-confirm:hover {
            background-color: #0056b3;
        }

        .btn-gpio-confirm:active {
            background-color: #004085;
        }

        .gpio-confirm-status {
            font-size: 12px;
            color: #28a745;
            font-weight: bold;
            white-space: nowrap;
        }

        /* OneNET 回復框樣式 */
        .onenet-response-box {
            background-color: #f9f9f9;
            border: 2px solid #007bff;
            border-radius: 12px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 14px;
            color: #333;
            display: none;
            word-break: break-word;
            font-family: 'Courier New', monospace;
        }

        .onenet-response-box.show {
            display: block;
        }

        .onenet-response-box.success {
            border-color: #28a745;
            background-color: #f1f9f6;
            color: #155724;
        }

        .onenet-response-box.error {
            border-color: #dc3545;
            background-color: #fdf1f3;
            color: #721c24;
        }

        .onenet-response-box.info {
            border-color: #17a2b8;
            background-color: #f0f7fa;
            color: #0c5460;
        }
    </style>
</head>

<body>
    <div class="sidebar" id="sidebar">
        <img src="移動教育logo.png" alt="Logo">
        <ul>
            <li><a href="#" onclick="showPage('homepage')">首頁</a></li>
            <li><a href="#" onclick="showPage('sensorConfig')">傳感器配置</a></li>
            <li><a href="#" onclick="showPage('gpioControl')">GPIO控制台</a></li>
            <li><a href="#" onclick="showPage('aiChat')">AI對話</a></li>
            <li><a href="#" onclick="showPage('settings')">基本設置</a></li>
            <li><a href="#" onclick="showPage('serialLog')">串口日志</a></li>
        </ul>
    </div>
    <button class="toggle-btn" onclick="toggleSidebar()"></button>
    <div class="content" id="content">
        <div id="homepage" class="page active">
            <div class="homepage-title">眾智成城 V2 智能實驗探頭</div>
            <div class="homepage-subtitle">控制臺</div>

            <!-- 按鈕部分 -->
            <div class="button-section">
                <button class="connect-btn disconnected" id="connectBtn" onclick="handleDeviceConnection()">
                    連接設備
                </button>
            </div>

            <!-- 傳感器監控部分 -->
            <div class="sensor-section">
                <div class="section-title">傳感器監控</div>
                <div class="sensor-charts" id="sensorChartsContainer">
                    <!-- 傳感器圖表將在此呈現 -->
                    <div class="no-sensor">暫無傳感器數據</div>
                </div>
            </div>

            <!-- GPIO 狀態部分 -->
            <div class="gpio-section">
                <div class="section-title">GPIO 狀態</div>
                <div class="gpio-control-container">
                    <table class="gpio-control-table">
                        <thead>
                            <tr>
                                <th>GPIO名</th>
                                <th>類型</th>
                                <th>控制</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody id="gpioControlTableBody">
                            <tr>
                                <td colspan="4" class="no-gpio-message">暫無 GPIO 配置</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <div id="sensorConfig" class="page">
            <h1>傳感器配置</h1>
            <div class="sensor-config-section">
                <div class="sensor-config-actions">
                    <button class="btn-add" onclick="openAddSensorModal()">新增+</button>
                </div>
                <div class="sensor-list-container">
                    <table class="sensor-list-table">
                        <thead>
                            <tr>
                                <th>傳感器名稱</th>
                                <th>傳感器種類</th>
                                <th>GPIO</th>
                                <th>最後活躍時間</th>
                                <th style="width: 60px;">操作</th>
                            </tr>
                        </thead>
                        <tbody id="sensorListBody">
                            <tr>
                                <td colspan="5" class="no-sensor-message">暫無傳感器，請點擊"新增+"按鈕添加傳感器</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- 新增傳感器模態框 -->
        <div id="addSensorModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">新增傳感器</div>
                <div class="modal-status" id="modalStatus"></div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="sensorName">傳感器名稱：</label>
                        <input type="text" id="sensorName" placeholder="輸入傳感器名稱">
                        <div class="error-message" id="nameError"></div>
                    </div>
                    <div class="form-group">
                        <label for="sensorType">傳感器種類：</label>
                        <select id="sensorType">
                            <option value="">請選擇</option>
                            <option value="DHT11">DHT11</option>
                            <option value="analog">analog</option>
                            <option value="digital">digital</option>
                        </select>
                        <div class="error-message" id="typeError"></div>
                    </div>
                    <div class="form-group">
                        <label for="sensorGPIO">GPIO：</label>
                        <select id="sensorGPIO">
                            <option value="">請選擇</option>
                        </select>
                        <div class="error-message" id="gpioError"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-confirm" onclick="confirmAddSensor()">確定</button>
                    <button class="btn-cancel" onclick="closeAddSensorModal()">取消</button>
                </div>
            </div>
        </div>
        <div id="gpioControl" class="page">
            <h1>GPIO控制台</h1>
            <p>設置要把哪些GPIO作為output pin（不能使用傳感器已經使用的pin）。</p>
            <div class="sensor-config-section">
                <div class="sensor-config-actions">
                    <button class="btn-add" onclick="openAddGPIOModal()">新增+</button>
                </div>
                <div class="sensor-list-container">
                    <table class="sensor-list-table">
                        <thead>
                            <tr>
                                <th>GPIO名稱</th>
                                <th>GPIO Pin</th>
                                <th>輸出模式</th>
                                <th>狀態</th>
                                <th style="width: 60px;">操作</th>
                            </tr>
                        </thead>
                        <tbody id="gpioListBody">
                            <tr>
                                <td colspan="5" class="no-sensor-message">暫無GPIO配置，請點擊"新增+"按鈕添加GPIO</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- 新增GPIO模態框 -->
        <div id="addGPIOModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">新增GPIO</div>
                <div class="modal-status" id="gpioModalStatus"></div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="gpioName">GPIO名稱：</label>
                        <input type="text" id="gpioName" placeholder="輸入GPIO名稱">
                        <div class="error-message" id="gpioNameError"></div>
                    </div>
                    <div class="form-group">
                        <label for="gpioPin">GPIO Pin：</label>
                        <select id="gpioPin">
                            <option value="">請選擇</option>
                        </select>
                        <div class="error-message" id="gpioPinError"></div>
                    </div>
                    <div class="form-group">
                        <label for="gpioMode">輸出模式：</label>
                        <select id="gpioMode">
                            <option value="">請選擇</option>
                            <option value="digital">Digital</option>
                            <option value="analog">Analog</option>
                        </select>
                        <div class="error-message" id="gpioModeError"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-confirm" onclick="confirmAddGPIO()">確定</button>
                    <button class="btn-cancel" onclick="closeAddGPIOModal()">取消</button>
                </div>
            </div>
        </div>
        <div id="aiChat" class="page">
            <h1>AI對話</h1>
            <p>此頁面尚未確定內容。</p>
        </div>
        <div id="settings" class="page">
            <h1>基本設置</h1>
            <p>設置oneNET平台的device ID, product name, product key, userID, user accesskey等。</p>

            <!-- OneNET設置區域 -->
            <div class="settings-section">
                <h2>OneNET</h2>
                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="userID">User_ID <span class="required-mark">*</span></label>
                            <input type="text" id="userID" placeholder="輸入User ID">
                        </div>
                    </div>
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="userAccessKey">User_AccessKey <span class="required-mark">*</span></label>
                            <input type="text" id="userAccessKey" placeholder="輸入User AccessKey">
                        </div>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="productID">Product ID <span class="required-mark">*</span></label>
                            <input type="text" id="productID" placeholder="輸入Product ID">
                        </div>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="deviceName">Device Name <span class="required-mark">*</span></label>
                            <input type="text" id="deviceName" placeholder="輸入Device Name">
                        </div>
                    </div>
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="deviceKey">Device Key <span class="required-mark">*</span></label>
                            <input type="text" id="deviceKey" placeholder="輸入Device Key">
                        </div>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="imei">IMEI</label>
                            <input type="text" id="imei" placeholder="輸入IMEI">
                        </div>
                    </div>
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="imsi">IMSI</label>
                            <input type="text" id="imsi" placeholder="輸入IMSI">
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="btn-confirm" onclick="connectToOneNET()">連接</button>
                    <button class="btn-cancel" onclick="disconnectFromOneNET()">斷開</button>
                </div>
                <div class="onenet-response-box" id="onenetResponseBox">
                    <!-- OneNET回復信息将在這裡顯示 -->
                </div>
            </div>

            <!-- 重置傳感器設置區域 -->
            <div class="settings-reset-section">
                <h2>重置設置</h2>
                <div class="reset-warning">
                    <p><strong>警告：</strong>點擊下方按鈕將清除所有已創建的傳感器和GPIO配置。此操作無法撤銷！</p>
                </div>
                <button class="btn-reset" onclick="resetAllSettings()">重置所有傳感器設置和GPIO選項</button>
            </div>
        </div>
        <div id="serialLog" class="page">
            <h1>串口日志</h1>
            <div class="serial-log-section">
                <div class="log-controls">
                    <button id="clearLogBtn" onclick="clearSerialLog()">清空日志</button>
                    <button id="exportLogBtn" onclick="exportSerialLog()">匯出日志</button>
                    <label style="margin-left: 20px; font-weight: bold;">
                        <input type="checkbox" id="autoScrollCheckbox" checked onchange="toggleAutoScroll()"> 自動滾動
                    </label>
                </div>
                <div class="log-display" id="logDisplay">
                    <div class="no-log">等待連接設備並接收數據...</div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // 全局狀態管理
        let deviceConnected = false;
        let serialPort = null;
        let reader = null;
        let charts = {}; // 動態圖表 {sensorName: chartInstance}
        let sensorDataMap = {}; // 傳感器數據 {sensorName: {unit, data: []}}
        let sensorConfig = {}; // 傳感器配置 {id: {name, type, gpio, lastActive}}
        let gpioConfig = {}; // GPIO 配置 {id: {name, pin, mode, status}}
        let serialLogHistory = []; // 串口日志歷史
        let autoScroll = true; // 自動滾動標記
        let usedGPIOs = {}; // 已使用的GPIO {io: sensorId}
        let sensorIdCounter = 0; // 傳感器ID計數器
        let gpioIdCounter = 0; // GPIO ID計數器
        let gpioConfirmStatus = {}; // GPIO 確認狀態 {gpioId: {pin, confirmed, value}}
        let serialReceiveBuffer = ''; // 串口接收缓冲区，用于处理分片数据
        let colorPalette = ['#dc3545', '#007bff', '#28a745', '#ffc107', '#17a2b8', '#fd7e14', '#6f42c1', '#20c997']; // 圖表顏色調色板
        let colorIndex = 0; // 顏色索引
        let pendingDHT11Config = {}; // 待創建的DHT11傳感器 {gpio: {sensorId, name, type, gpio}}
        let pendingDHT11Delete = {}; // 待刪除的DHT11傳感器 {gpio: sensorId}

        // 處理設備連接
        async function handleDeviceConnection() {
            const btn = document.getElementById('connectBtn');

            if (deviceConnected) {
                // 斷開連接
                await disconnectDevice();
            } else {
                // 連接設備
                await connectDevice();
            }
        }

        // 連接設備
        async function connectDevice() {
            try {
                // 請求用戶選擇串口
                serialPort = await navigator.serial.requestPort();

                // 打開串口
                await serialPort.open({ baudRate: 115200 });

                deviceConnected = true;
                addSerialLog('系統: 連接成功，波特率115200', 'system');
                updateConnectButton();

                // 開始讀取數據
                readFromDevice();

            } catch (error) {
                console.error('連接失敗:', error);
                addSerialLog('錯誤: ' + error.message, 'error');
                alert('連接失敗: ' + error.message);
                deviceConnected = false;
                updateConnectButton();
            }
        }

        // 斷開設備連接
        async function disconnectDevice() {
            try {
                if (reader) {
                    await reader.cancel();
                }
                if (serialPort) {
                    await serialPort.close();
                }
                deviceConnected = false;
                serialReceiveBuffer = ''; // 清空接收緩衝區
                addSerialLog('系統: 設備已斷開連接', 'system');
                updateConnectButton();
            } catch (error) {
                console.error('斷開連接失敗:', error);
                addSerialLog('錯誤: ' + error.message, 'error');
            }
        }

        // 更新連接按鈕狀態
        function updateConnectButton() {
            const btn = document.getElementById('connectBtn');
            if (deviceConnected) {
                btn.classList.remove('disconnected');
                btn.classList.add('connected');
                btn.textContent = '斷開連接';
            } else {
                btn.classList.remove('connected');
                btn.classList.add('disconnected');
                btn.textContent = '連接設備';
            }
        }

        // 從設備讀取數據
        async function readFromDevice() {
            try {
                reader = serialPort.readable.getReader();
                addSerialLog('系統: 開始讀取串口數據', 'system');
                serialReceiveBuffer = ''; // 初始化接收缓冲区

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        break;
                    }

                    // 處理接收到的數據
                    const decoder = new TextDecoder();
                    const dataChunk = decoder.decode(value);
                    console.log('接收數據塊:', dataChunk);

                    // 將數據添加到緩衝區
                    serialReceiveBuffer += dataChunk;

                    // 按行分割緩衝區中的數據
                    // 支持 \n、\r\n、\r 三種換行符
                    const lines = serialReceiveBuffer.split(/\r\n|\r|\n/);

                    // 最後一個元素可能不是完整的行（沒有換行符），保留在緩衝區中
                    serialReceiveBuffer = lines.pop() || '';

                    // 處理每一行完整的數據
                    for (const line of lines) {
                        if (line.trim()) { // 忽略空行
                            console.log('完整行數據:', line);

                            // 記錄接收到的數據（按行記錄）
                            addSerialLog(line, 'receive');

                            // 檢查是否是 GPIO 設置確認回復
                            handleGPIOConfirmation(line);

                            // 檢查是否是 DHT11 確認回復
                            handleDHT11Confirmation(line);

                            // 解析數據並更新圖表
                            processSensorData(line);
                        }
                    }
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('讀取數據錯誤:', error);
                    addSerialLog('錯誤: ' + error.message, 'error');
                    deviceConnected = false;
                    updateConnectButton();
                }
            }
        }

        // 處理傳感器數據 - 解析格式: [sensor][name][unit]=value
        function processSensorData(data) {
            try {
                // 匹配格式: [sensor][sensorName][unit]=value
                const match = data.match(/\[sensor\]\[([^\]]+)\]\[([^\]]+)\]=([\d\.-]+)/);
                if (!match) {
                    console.log('非傳感器數據或格式不匹配:', data);
                    return;
                }

                const sensorName = match[1]; // 例如: 'ax', 'ay', 'az', 'gx', 'gy', 'gz', 'g'
                const unit = match[2];       // 例如: 'g', 'dps', 'm/s²'
                const value = parseFloat(match[3]); // 數值

                // 初始化傳感器數據（如果不存在）
                if (!sensorDataMap[sensorName]) {
                    sensorDataMap[sensorName] = {
                        unit: unit,
                        data: [],
                        timestamps: []
                    };
                    // 為新傳感器創建圖表
                    createSensorChart(sensorName, unit);
                }

                // 添加新數據點
                const now = new Date();
                const timeString = now.toLocaleTimeString('zh-HK', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                sensorDataMap[sensorName].data.push(value);
                sensorDataMap[sensorName].timestamps.push(timeString);

                // 限制數據點數量（只保留最近 40 個點）
                const maxDataPoints = 40;
                if (sensorDataMap[sensorName].data.length > maxDataPoints) {
                    sensorDataMap[sensorName].data.shift();
                    sensorDataMap[sensorName].timestamps.shift();
                }

                // 更新圖表
                if (charts[sensorName]) {
                    const chart = charts[sensorName];
                    chart.data.labels = sensorDataMap[sensorName].timestamps;
                    chart.data.datasets[0].data = sensorDataMap[sensorName].data;
                    chart.update('none'); // 使用 'none' 避免過多的重繪動畫
                }
            } catch (error) {
                console.error('處理傳感器數據出錯:', error);
            }
        }

        // 創建傳感器圖表
        function createSensorChart(sensorName, unit) {
            const container = document.getElementById('sensorChartsContainer');

            // 如果容器是空的或有提示信息，先清空
            if (container.innerHTML.includes('no-sensor') || Object.keys(charts).length === 0) {
                container.innerHTML = '';
            }

            // 創建圖表容器
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.id = `chart-container-${sensorName}`;

            const chartTitle = document.createElement('div');
            chartTitle.className = 'chart-title';
            chartTitle.textContent = `${sensorName} (${unit})`;

            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'chart-wrapper';

            const canvas = document.createElement('canvas');
            canvas.id = `chart-${sensorName}`;

            canvasWrapper.appendChild(canvas);
            chartContainer.appendChild(chartTitle);
            chartContainer.appendChild(canvasWrapper);
            container.appendChild(chartContainer);

            // 選擇顏色
            const color = colorPalette[colorIndex % colorPalette.length];
            colorIndex++;

            // 創建 Chart.js 圖表
            const ctx = canvas.getContext('2d');
            charts[sensorName] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: sensorName,
                        data: [],
                        borderColor: color,
                        backgroundColor: color + '1a', // 10% 透明度
                        tension: 0.4,
                        fill: true,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointBackgroundColor: color
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false
                        }
                    }
                }
            });

            console.log(`創建圖表: ${sensorName}`);
        }

        // 初始化 GPIO 列表（首頁GPIO狀態，用表格顯示）
        function initializeGPIOList() {
            const tbody = document.getElementById('gpioControlTableBody');

            // 如果沒有配置，顯示提示信息
            if (Object.keys(gpioConfig).length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="no-gpio-message">暫無 GPIO 配置。請在"GPIO控制臺"中配置。</td></tr>';
                return;
            }

            tbody.innerHTML = '';

            // 顯示每個 GPIO 的狀態
            for (const [gpioId, config] of Object.entries(gpioConfig)) {
                const row = document.createElement('tr');
                row.id = `gpio-row-${gpioId}`;

                // GPIO 名稱列
                const nameCell = document.createElement('td');
                nameCell.textContent = escapeHtml(config.name);

                // 類型列
                const typeCell = document.createElement('td');
                typeCell.textContent = config.mode === 'digital' ? 'Digital' : 'Analog';

                // 控制列
                const controlCell = document.createElement('td');
                controlCell.id = `gpio-control-${gpioId}`;

                if (config.mode === 'digital') {
                    // Digital: 開關
                    const toggle = document.createElement('div');
                    toggle.className = `toggle-switch ${config.status === 'HIGH' ? 'on' : ''}`;
                    toggle.id = `toggle-${gpioId}`;
                    toggle.onclick = () => toggleDigitalGPIO(gpioId);
                    controlCell.appendChild(toggle);
                } else {
                    // Analog: 滑塊
                    const container = document.createElement('div');
                    container.className = 'analog-slider-container';

                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.min = '0';
                    slider.max = '255';
                    slider.value = parseInt(config.status) || 0;
                    slider.className = 'analog-slider';
                    slider.id = `slider-${gpioId}`;
                    slider.oninput = () => updateAnalogGPIO(gpioId, slider.value);

                    const valueDisplay = document.createElement('span');
                    valueDisplay.className = 'analog-value';
                    valueDisplay.id = `value-${gpioId}`;
                    valueDisplay.textContent = parseInt(config.status) || 0;

                    container.appendChild(slider);
                    container.appendChild(valueDisplay);
                    controlCell.appendChild(container);
                }

                // 操作列（確定按鈕和確認狀態）
                const actionCell = document.createElement('td');
                actionCell.id = `gpio-action-${gpioId}`;
                actionCell.className = 'gpio-action-cell';

                const confirmBtn = document.createElement('button');
                confirmBtn.className = 'btn-gpio-confirm';
                confirmBtn.textContent = '確定';
                confirmBtn.onclick = () => confirmGPIOValue(gpioId);

                const statusSpan = document.createElement('span');
                statusSpan.id = `gpio-status-${gpioId}`;
                statusSpan.className = 'gpio-confirm-status';

                // 如果已經確認過，顯示確認狀態
                if (gpioConfirmStatus[gpioId] && gpioConfirmStatus[gpioId].confirmed) {
                    statusSpan.textContent = `當前${config.pin}=${gpioConfirmStatus[gpioId].value}`;
                }

                actionCell.appendChild(confirmBtn);
                actionCell.appendChild(statusSpan);

                row.appendChild(nameCell);
                row.appendChild(typeCell);
                row.appendChild(controlCell);
                row.appendChild(actionCell);
                tbody.appendChild(row);
            }
        }

        // 切換 Digital GPIO
        function toggleDigitalGPIO(gpioId) {
            if (gpioConfig[gpioId]) {
                const currentStatus = gpioConfig[gpioId].status;
                gpioConfig[gpioId].status = currentStatus === 'HIGH' ? 'LOW' : 'HIGH';

                // 更新toggle開關的狀態
                const toggle = document.getElementById(`toggle-${gpioId}`);
                if (toggle) {
                    toggle.classList.toggle('on');
                }

                // 保存配置
                saveGPIOConfig();

                // 發送數據給設備（如果連接了）
                if (deviceConnected) {
                    sendGPIOCommand(gpioId, gpioConfig[gpioId].status);
                }
            }
        }

        // 更新 Analog GPIO
        function updateAnalogGPIO(gpioId, value) {
            if (gpioConfig[gpioId]) {
                gpioConfig[gpioId].status = value.toString();

                // 更新數值顯示
                const valueDisplay = document.getElementById(`value-${gpioId}`);
                if (valueDisplay) {
                    valueDisplay.textContent = value;
                }

                // 保存配置
                saveGPIOConfig();

                // 發送數據給設備（如果連接了）
                if (deviceConnected) {
                    sendGPIOCommand(gpioId, value);
                }
            }
        }

        // 發送GPIO命令給設備
        async function sendGPIOCommand(gpioId, value) {
            if (!deviceConnected || !serialPort) return;

            try {
                const config = gpioConfig[gpioId];
                const command = JSON.stringify({
                    cmd: 'gpio_control',
                    gpio: config.pin,
                    mode: config.mode,
                    value: value
                });

                const writer = serialPort.writable.getWriter();
                const encoder = new TextEncoder();
                await writer.write(encoder.encode(command + '\n'));
                writer.releaseLock();

                addSerialLog(`發送GPIO命令: ${command}`, 'send');
            } catch (error) {
                console.error('發送GPIO命令失敗:', error);
                addSerialLog('錯誤: 發送GPIO命令失敗 - ' + error.message, 'error');
            }
        }

        // 發送DHT11添加命令給設備
        async function sendDHT11AddCommand(gpio) {
            if (!deviceConnected || !serialPort) return;

            try {
                const command = `AT+ADDDHT11=${gpio}`;
                const writer = serialPort.writable.getWriter();
                const encoder = new TextEncoder();
                await writer.write(encoder.encode(command + '\r\n'));
                writer.releaseLock();

                addSerialLog(`發送DHT11添加命令: ${command}`, 'send');
            } catch (error) {
                console.error('發送DHT11添加命令失敗:', error);
                addSerialLog('錯誤: 發送DHT11添加命令失敗 - ' + error.message, 'error');
            }
        }

        // 發送DHT11刪除命令給設備
        async function sendDHT11DeleteCommand(gpio) {
            if (!deviceConnected || !serialPort) return;

            try {
                const command = `AT+DELDHT11=${gpio}`;
                const writer = serialPort.writable.getWriter();
                const encoder = new TextEncoder();
                await writer.write(encoder.encode(command + '\r\n'));
                writer.releaseLock();

                addSerialLog(`發送DHT11刪除命令: ${command}`, 'send');
            } catch (error) {
                console.error('發送DHT11刪除命令失敗:', error);
                addSerialLog('錯誤: 發送DHT11刪除命令失敗 - ' + error.message, 'error');
            }
        }

        // 更新 GPIO 狀態（來自設備數據）
        function updateGPIOStatus(gpioId, value) {
            if (gpioConfig[gpioId]) {
                gpioConfig[gpioId].status = value;
                initializeGPIOList(); // 重新渲染列表
            }
        }

        // 確認 GPIO 值（發送AT命令給設備）
        async function confirmGPIOValue(gpioId) {
            if (!deviceConnected || !serialPort) {
                alert('請先連接設備');
                return;
            }

            const config = gpioConfig[gpioId];
            if (!config) return;

            try {
                // 構建AT命令格式
                let value;
                if (config.mode === 'digital') {
                    value = config.status === 'HIGH' ? 1 : 0;
                } else {
                    value = parseInt(config.status) || 0;
                }

                const command = `AT+${config.pin}=${value}`;

                // 發送命令
                const writer = serialPort.writable.getWriter();
                const encoder = new TextEncoder();
                await writer.write(encoder.encode(command + '\r\n'));
                writer.releaseLock();

                addSerialLog(`發送GPIO確定命令: ${command}`, 'send');

                // 設置等待確認的狀態
                gpioConfirmStatus[gpioId] = {
                    pin: config.pin,
                    confirmed: false,
                    value: value,
                    timestamp: Date.now()
                };

                // 60秒後如果還沒收到確認，則超時
                setTimeout(() => {
                    if (gpioConfirmStatus[gpioId] && !gpioConfirmStatus[gpioId].confirmed) {
                        addSerialLog(`警告: ${config.pin} 設置超時（60秒內無回復）`, 'error');
                        delete gpioConfirmStatus[gpioId];
                    }
                }, 60000);

            } catch (error) {
                console.error('發送GPIO確定命令失敗:', error);
                addSerialLog('錯誤: 發送GPIO確定命令失敗 - ' + error.message, 'error');
            }
        }

        // 處理設備回復的GPIO設置確認
        function handleGPIOConfirmation(message) {
            // 匹配格式 "[设置]IO2=100" 或 "[設置]IO2=100"
            const confirmPattern = /\[.*?\](IO\d+)=(\d+)/;
            const match = message.match(confirmPattern);

            if (match) {
                const pin = match[1];
                const value = match[2];

                // 查找對應的gpioId
                for (const [gpioId, config] of Object.entries(gpioConfig)) {
                    if (config.pin === pin) {
                        gpioConfirmStatus[gpioId] = {
                            pin: pin,
                            confirmed: true,
                            value: value,
                            timestamp: Date.now()
                        };

                        // 更新UI顯示確認狀態
                        const statusSpan = document.getElementById(`gpio-status-${gpioId}`);
                        if (statusSpan) {
                            statusSpan.textContent = `當前${pin}=${value}`;
                        }

                        addSerialLog(`GPIO 設置確認: ${pin}=${value}`, 'receive');
                        break;
                    }
                }
            }
        }

        // 處理設備回復的DHT11確認
        function handleDHT11Confirmation(message) {
            // 匹配格式 "[DHT] 已添加DHT11: *GPIO*" 或 "[DHT] 已添加DHT11: IO27"
            const addPattern = /\[DHT\]\s*已添加DHT11:\s*(IO\d+)/;
            const addMatch = message.match(addPattern);

            if (addMatch) {
                const gpio = addMatch[1];
                addSerialLog(`DHT11 添加確認: ${gpio} 已成功添加`, 'system');

                // 檢查是否有待創建的傳感器
                if (pendingDHT11Config[gpio]) {
                    const pendingConfig = pendingDHT11Config[gpio];
                    const sensorId = pendingConfig.sensorId;

                    // 現在真正保存配置
                    sensorConfig[sensorId] = {
                        id: sensorId,
                        name: pendingConfig.name,
                        type: pendingConfig.type,
                        gpio: pendingConfig.gpio,
                        lastActive: pendingConfig.lastActive
                    };

                    // 標記GPIO為已使用
                    usedGPIOs[gpio] = sensorId;

                    // 清除待創建狀態
                    delete pendingDHT11Config[gpio];

                    // 保存配置
                    saveSensorConfig();

                    // 更新UI
                    updateSensorList();

                    // 顯示成功消息
                    showModalStatus('創建成功', 'success');

                    // 延迟 1 秒後關閉模態框
                    setTimeout(() => {
                        closeAddSensorModal();
                    }, 1000);
                }
                return;
            }

            // 匹配格式 "[DHT] 已删除DHT11: *GPIO*" 或 "[DHT] 已删除DHT11: IO27"
            const delPattern = /\[DHT\]\s*已删除DHT11:\s*(IO\d+)/;
            const delMatch = message.match(delPattern);

            if (delMatch) {
                const gpio = delMatch[1];
                addSerialLog(`DHT11 刪除確認: ${gpio} 已成功刪除`, 'system');

                // 檢查是否有待刪除的傳感器
                if (pendingDHT11Delete[gpio]) {
                    const sensorId = pendingDHT11Delete[gpio];
                    const config = sensorConfig[sensorId];

                    // 真正刪除配置
                    if (config && config.gpio) {
                        delete usedGPIOs[config.gpio];
                    }
                    delete sensorConfig[sensorId];

                    // 清除待刪除狀態
                    delete pendingDHT11Delete[gpio];

                    // 保存配置
                    saveSensorConfig();

                    // 更新UI
                    updateSensorList();

                    addSerialLog(`DHT11 傳感器 ${sensorId} 已從系統中移除`, 'system');
                }
            }
        }

        // 監聽設備連接/斷開事件
        navigator.serial.addEventListener('disconnect', () => {
            if (deviceConnected) {
                deviceConnected = false;
                updateConnectButton();
                addSerialLog('系統: 設備已物理斷開連接', 'system');
                console.log('設備已斷開連接');
            }
        });

        // 頁面加載時初始化
        document.addEventListener('DOMContentLoaded', function () {
            // 不需要預先初始化圖表，圖表會根據接收到的串口數據動態創建
            initializeGPIOList();
            updateConnectButton();
            loadSavedSettings();
        });

        // 顯示頁面
        function showPage(pageId) {
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');

            // 如果是首頁，重新初始化圖表
            if (pageId === 'homepage') {
                setTimeout(() => {
                    for (const chart of Object.values(charts)) {
                        chart.resize();
                    }
                }, 100);
            }
        }

        // 切換側邊欄
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const content = document.getElementById('content');
            sidebar.classList.toggle('collapsed');
            content.classList.toggle('expanded');
        }

        // 添加串口日志條目
        function addSerialLog(message, type = 'system') {
            const timestamp = new Date().toLocaleTimeString('zh-HK', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const logEntry = {
                timestamp: timestamp,
                message: message,
                type: type
            };

            serialLogHistory.push(logEntry);

            // 保持日志不超過1000條
            if (serialLogHistory.length > 1000) {
                serialLogHistory.shift();
            }

            updateSerialLogDisplay();
        }

        // 更新串口日志顯示
        function updateSerialLogDisplay() {
            const logDisplay = document.getElementById('logDisplay');

            if (serialLogHistory.length === 0) {
                logDisplay.innerHTML = '<div class="no-log">等待連接設備並接收數據...</div>';
                return;
            }

            logDisplay.innerHTML = serialLogHistory.map(entry => {
                // 將換行符(\n)和回車符(\r)轉換為HTML的<br>標籤
                const messageWithLineBreaks = escapeHtml(entry.message)
                    .replace(/\r\n/g, '<br>')
                    .replace(/\r/g, '<br>')
                    .replace(/\n/g, '<br>');
                return `<div class="log-entry ${entry.type}"><span class="log-timestamp">[${entry.timestamp}]</span>${messageWithLineBreaks}</div>`;
            }).join('');

            // 自動滾動到底部
            if (autoScroll) {
                logDisplay.scrollTop = logDisplay.scrollHeight;
            }
        }

        // HTML 轉義函數
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // 清空日志
        function clearSerialLog() {
            if (confirm('確定要清空所有日志嗎？')) {
                serialLogHistory = [];
                updateSerialLogDisplay();
            }
        }

        // 匯出日志
        function exportSerialLog() {
            if (serialLogHistory.length === 0) {
                alert('沒有日志可匯出');
                return;
            }

            const logText = serialLogHistory.map(entry =>
                `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
            ).join('\n');

            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `serial-log-${new Date().getTime()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 切換自動滾動
        function toggleAutoScroll() {
            autoScroll = document.getElementById('autoScrollCheckbox').checked;
            if (autoScroll) {
                const logDisplay = document.getElementById('logDisplay');
                logDisplay.scrollTop = logDisplay.scrollHeight;
            }
        }

        // ==================== 傳感器配置功能 ====================

        // 初始化GPIO選項
        function initializeGPIOOptions() {
            const gpioSelect = document.getElementById('sensorGPIO');
            const availableGPIOs = ['IO2', 'IO32', 'IO27'];

            // 清除現有選項（保留"請選擇"）
            while (gpioSelect.children.length > 1) {
                gpioSelect.removeChild(gpioSelect.lastChild);
            }

            // 添加可用的GPIO選項（排除已使用的GPIO）
            availableGPIOs.forEach(gpio => {
                // 檢查GPIO是否被傳感器或GPIO控制臺使用
                const isUsedBySensor = usedGPIOs[gpio];
                const isUsedByGPIOControl = Object.values(gpioConfig).some(config => config.pin === gpio);

                if (!isUsedBySensor && !isUsedByGPIOControl) {
                    const option = document.createElement('option');
                    option.value = gpio;
                    option.textContent = gpio;
                    gpioSelect.appendChild(option);
                }
            });
        }

        // 打開新增傳感器模態框
        function openAddSensorModal() {
            initializeGPIOOptions();
            clearModalForm();
            document.getElementById('addSensorModal').classList.add('show');
        }

        // 關閉新增傳感器模態框
        function closeAddSensorModal() {
            // 立即隱藏模態框
            document.getElementById('addSensorModal').classList.remove('show');
            // 清除表單數據
            clearModalForm();
        }

        // 清除模態框表單
        function clearModalForm() {
            document.getElementById('sensorName').value = '';
            document.getElementById('sensorType').value = '';
            document.getElementById('sensorGPIO').value = '';
            document.getElementById('nameError').textContent = '';
            document.getElementById('typeError').textContent = '';
            document.getElementById('gpioError').textContent = '';
            clearModalStatus();
        }

        // 清除模態框狀態消息
        function clearModalStatus() {
            const statusDiv = document.getElementById('modalStatus');
            statusDiv.textContent = '';
            statusDiv.classList.remove('show', 'success', 'error');
        }

        // 顯示模態框狀態消息
        function showModalStatus(message, type) {
            const statusDiv = document.getElementById('modalStatus');
            statusDiv.textContent = message;
            statusDiv.classList.add('show', type);
        }

        // 驗證和添加傳感器
        function confirmAddSensor() {
            const name = document.getElementById('sensorName').value.trim();
            const type = document.getElementById('sensorType').value;
            const gpio = document.getElementById('sensorGPIO').value;

            // 清除錯誤消息
            document.getElementById('nameError').textContent = '';
            document.getElementById('typeError').textContent = '';
            document.getElementById('gpioError').textContent = '';

            let hasError = false;
            let errorMessage = '';

            // 驗證傳感器名稱
            if (!name) {
                document.getElementById('nameError').textContent = '傳感器名稱不能為空';
                errorMessage = '缺少傳感器名稱';
                hasError = true;
            }

            // 驗證傳感器種類
            if (!type) {
                document.getElementById('typeError').textContent = '請選擇傳感器種類';
                if (!errorMessage) errorMessage = '未選擇傳感器種類';
                hasError = true;
            }

            // 驗證GPIO
            if (!gpio) {
                document.getElementById('gpioError').textContent = '請選擇GPIO';
                if (!errorMessage) errorMessage = '未選擇GPIO';
                hasError = true;
            }

            // 驗證GPIO是否已被使用
            if (gpio && usedGPIOs[gpio]) {
                document.getElementById('gpioError').textContent = '此GPIO已被其他傳感器使用，請選擇其他GPIO';
                if (!errorMessage) errorMessage = 'GPIO已被使用';
                hasError = true;
            }

            if (hasError) {
                showModalStatus(errorMessage, 'error');
                return;
            }

            // 如果是DHT11傳感器
            if (type === 'DHT11') {
                if (!deviceConnected) {
                    showModalStatus('錯誤: 設備未連接', 'error');
                    return;
                }

                // 創建臨時傳感器對象（不保存到sensorConfig）
                const sensorId = 'sensor_' + (++sensorIdCounter);
                const now = new Date();
                const lastActive = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                // 保存到待創建配置
                pendingDHT11Config[gpio] = {
                    sensorId: sensorId,
                    name: name,
                    type: type,
                    gpio: gpio,
                    lastActive: lastActive
                };

                // 不占用GPIO，只發送命令
                showModalStatus('創建中...', 'system');
                sendDHT11AddCommand(gpio);
            } else {
                // 非DHT11傳感器的処理邏輯保持不變
                // 創建傳感器對象
                const sensorId = 'sensor_' + (++sensorIdCounter);
                const now = new Date();
                const lastActive = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                sensorConfig[sensorId] = {
                    id: sensorId,
                    name: name,
                    type: type,
                    gpio: gpio,
                    lastActive: lastActive
                };

                // 標記GPIO為已使用
                usedGPIOs[gpio] = sensorId;

                // 保存配置到本地存儲
                saveSensorConfig();

                // 更新UI
                updateSensorList();

                // 顯示成功消息
                showModalStatus('創建成功', 'success');

                // 延迟 1 秒後關閉模態框
                setTimeout(() => {
                    closeAddSensorModal();
                }, 1000);
            }
        }

        // 更新傳感器列表
        function updateSensorList() {
            const tbody = document.getElementById('sensorListBody');

            if (Object.keys(sensorConfig).length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="no-sensor-message">暫無傳感器，請點擊"新增+"按鈕添加傳感器</td></tr>';
                return;
            }

            tbody.innerHTML = '';

            for (const [sensorId, config] of Object.entries(sensorConfig)) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(config.name)}</td>
                    <td>${escapeHtml(config.type)}</td>
                    <td>${escapeHtml(config.gpio)}</td>
                    <td>${escapeHtml(config.lastActive)}</td>
                    <td><button class="btn-delete-row" onclick="deleteSensor('${sensorId}')">刪除</button></td>
                `;
                tbody.appendChild(row);
            }
        }

        // 刪除單個傳感器
        function deleteSensor(sensorId) {
            if (!confirm('確定要刪除此傳感器嗎？')) {
                return;
            }

            const config = sensorConfig[sensorId];

            // 如果是DHT11傳感器
            if (config && config.type === 'DHT11') {
                if (!deviceConnected) {
                    alert('設備未連接，無法刪除DHT11傳感器');
                    return;
                }

                // 保存待刪除狀態
                pendingDHT11Delete[config.gpio] = sensorId;

                // 發送刪除命令
                sendDHT11DeleteCommand(config.gpio);
            } else {
                // 非DHT11傳感器的删除邏輯保持不變
                if (config && config.gpio) {
                    delete usedGPIOs[config.gpio];
                }
                delete sensorConfig[sensorId];

                updateSensorList();
                saveSensorConfig();
            }
        }

        // 切換全選
        function toggleSelectAll() {
            // 此函数已不再使用
        }

        // 更新刪除按鈕狀態
        function updateDeleteButton() {
            // 此函数已不再使用
        }

        // 刪除選中的傳感器
        function deleteSelectedSensors() {
            // 此函数已不再使用
        }

        // 保存傳感器配置到本地存儲
        function saveSensorConfig() {
            localStorage.setItem('sensorConfig', JSON.stringify(sensorConfig));
            localStorage.setItem('usedGPIOs', JSON.stringify(usedGPIOs));
            localStorage.setItem('sensorIdCounter', sensorIdCounter.toString());
        }

        // 從本地存儲加載傳感器配置
        function loadSensorConfig() {
            const saved = localStorage.getItem('sensorConfig');
            if (saved) {
                sensorConfig = JSON.parse(saved);
            }

            const savedGPIOs = localStorage.getItem('usedGPIOs');
            if (savedGPIOs) {
                usedGPIOs = JSON.parse(savedGPIOs);
            }

            const savedCounter = localStorage.getItem('sensorIdCounter');
            if (savedCounter) {
                sensorIdCounter = parseInt(savedCounter);
            }

            updateSensorList();
        }

        // 頁面初始化時加載傳感器配置
        window.addEventListener('load', function () {
            loadSensorConfig();
        });

        // 确保配置在初始化时加载
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadSensorConfig);
        } else {
            loadSensorConfig();
        }

        // ==================== GPIO 控制臺功能 ====================

        // 獲取可用的GPIO選項（排除已使用的GPIO）
        function getAvailableGPIOPins() {
            const allGPIOs = ['IO1', 'IO2', 'IO3'];
            const availableGPIOs = allGPIOs.filter(gpio => !usedGPIOs[gpio] && !Object.values(gpioConfig).some(config => config.pin === gpio));
            return availableGPIOs;
        }

        // 初始化GPIO選項（GPIO控制臺）
        function initializeGPIOPinOptions() {
            const gpioSelect = document.getElementById('gpioPin');
            const availableGPIOs = getAvailableGPIOPins();

            // 清除現有選項（保留"請選擇"）
            while (gpioSelect.children.length > 1) {
                gpioSelect.removeChild(gpioSelect.lastChild);
            }

            // 添加可用的GPIO選項
            availableGPIOs.forEach(gpio => {
                const option = document.createElement('option');
                option.value = gpio;
                option.textContent = gpio;
                gpioSelect.appendChild(option);
            });
        }

        // 打開新增GPIO模態框
        function openAddGPIOModal() {
            initializeGPIOPinOptions();
            clearGPIOModalForm();
            document.getElementById('addGPIOModal').classList.add('show');
        }

        // 關閉新增GPIO模態框
        function closeAddGPIOModal() {
            document.getElementById('addGPIOModal').classList.remove('show');
            clearGPIOModalForm();
        }

        // 清除GPIO模態框表單
        function clearGPIOModalForm() {
            document.getElementById('gpioName').value = '';
            document.getElementById('gpioPin').value = '';
            document.getElementById('gpioMode').value = '';
            document.getElementById('gpioNameError').textContent = '';
            document.getElementById('gpioPinError').textContent = '';
            document.getElementById('gpioModeError').textContent = '';
            clearGPIOModalStatus();
        }

        // 清除GPIO模態框狀態消息
        function clearGPIOModalStatus() {
            const statusDiv = document.getElementById('gpioModalStatus');
            statusDiv.textContent = '';
            statusDiv.classList.remove('show', 'success', 'error');
        }

        // 顯示GPIO模態框狀態消息
        function showGPIOModalStatus(message, type) {
            const statusDiv = document.getElementById('gpioModalStatus');
            statusDiv.textContent = message;
            statusDiv.classList.add('show', type);
        }

        // 驗證和添加GPIO
        function confirmAddGPIO() {
            const name = document.getElementById('gpioName').value.trim();
            const pin = document.getElementById('gpioPin').value;
            const mode = document.getElementById('gpioMode').value;

            // 清除錯誤消息
            document.getElementById('gpioNameError').textContent = '';
            document.getElementById('gpioPinError').textContent = '';
            document.getElementById('gpioModeError').textContent = '';

            let hasError = false;
            let errorMessage = '';

            // 驗證GPIO名稱
            if (!name) {
                document.getElementById('gpioNameError').textContent = 'GPIO名稱不能為空';
                errorMessage = '缺少GPIO名稱';
                hasError = true;
            }

            // 驗證GPIO Pin
            if (!pin) {
                document.getElementById('gpioPinError').textContent = '請選擇GPIO Pin';
                if (!errorMessage) errorMessage = '未選擇GPIO Pin';
                hasError = true;
            }

            // 驗證GPIO Pin是否已被使用
            if (pin && (usedGPIOs[pin] || Object.values(gpioConfig).some(config => config.pin === pin))) {
                document.getElementById('gpioPinError').textContent = '此GPIO已被使用，請選擇其他GPIO';
                if (!errorMessage) errorMessage = 'GPIO已被使用';
                hasError = true;
            }

            // 驗證輸出模式
            if (!mode) {
                document.getElementById('gpioModeError').textContent = '請選擇輸出模式';
                if (!errorMessage) errorMessage = '未選擇輸出模式';
                hasError = true;
            }

            if (hasError) {
                showGPIOModalStatus(errorMessage, 'error');
                return;
            }

            // 創建GPIO對象
            const gpioId = 'gpio_' + (++gpioIdCounter);

            gpioConfig[gpioId] = {
                id: gpioId,
                name: name,
                pin: pin,
                mode: mode,
                status: mode === 'digital' ? 'LOW' : '0'
            };

            // 保存配置到本地存儲
            saveGPIOConfig();

            // 更新UI（GPIO配置列表和首頁GPIO狀態）
            updateGPIOConfigList();

            // 顯示成功消息
            showGPIOModalStatus('創建成功', 'success');

            // 延迟 1 秒後關閉模態框
            setTimeout(() => {
                closeAddGPIOModal();
            }, 1000);
        }

        // 更新GPIO配置列表（GPIO控制臺頁面）
        function updateGPIOConfigList() {
            const tbody = document.getElementById('gpioListBody');

            if (Object.keys(gpioConfig).length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="no-sensor-message">暫無GPIO配置，請點擊"新增+"按鈕添加GPIO</td></tr>';
                return;
            }

            tbody.innerHTML = '';

            for (const [gpioId, config] of Object.entries(gpioConfig)) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(config.name)}</td>
                    <td>${escapeHtml(config.pin)}</td>
                    <td>${config.mode === 'digital' ? 'Digital' : 'Analog'}</td>
                    <td>${escapeHtml(config.status)}</td>
                    <td><button class="btn-delete-row" onclick="deleteGPIO('${gpioId}')">刪除</button></td>
                `;
                tbody.appendChild(row);
            }

            // 同時更新首頁的GPIO狀態
            initializeGPIOList();
        }

        // 刪除單個GPIO
        function deleteGPIO(gpioId) {
            if (!confirm('確定要刪除此GPIO嗎？')) {
                return;
            }

            delete gpioConfig[gpioId];
            saveGPIOConfig();
            updateGPIOConfigList();
        }

        // 保存GPIO配置到本地存儲
        function saveGPIOConfig() {
            localStorage.setItem('gpioConfig', JSON.stringify(gpioConfig));
            localStorage.setItem('gpioIdCounter', gpioIdCounter.toString());
        }

        // 從本地存儲加載GPIO配置
        function loadGPIOConfig() {
            const saved = localStorage.getItem('gpioConfig');
            if (saved) {
                gpioConfig = JSON.parse(saved);
            }

            const savedCounter = localStorage.getItem('gpioIdCounter');
            if (savedCounter) {
                gpioIdCounter = parseInt(savedCounter);
            }

            updateGPIOConfigList();
            initializeGPIOList();
        }

        // 頁面初始化時加載GPIO配置
        window.addEventListener('load', function () {
            loadGPIOConfig();
        });

        // 确保GPIO配置在初始化时加载
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadGPIOConfig);
        } else {
            loadGPIOConfig();
        }

        // ==================== 重置設置功能 ====================

        // 保存WiFi設置
        // 顯示OneNET回復信息
        function showOneNETResponse(message, type = 'info') {
            const responseBox = document.getElementById('onenetResponseBox');
            responseBox.textContent = message;
            responseBox.className = `onenet-response-box show ${type}`;

            // 自動清除錯誤消息（10秒後）
            if (type === 'error') {
                setTimeout(() => {
                    responseBox.classList.remove('show');
                }, 10000);
            }
        }

        // 計算OneNET Token - 使用後端API（推薦方式）
        async function calculateOneNETToken(productId, deviceName, deviceKey) {
            try {
                console.log('[前端Token計算] 呼叫後端API計算Token');

                const response = await fetch('http://localhost:3000/api/onenet/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        productId: productId,
                        deviceName: deviceName,
                        deviceKey: deviceKey
                    })
                });

                if (!response.ok) {
                    throw new Error(`後端返回錯誤: ${response.status}`);
                }

                const result = await response.json();

                if (result.success && result.token) {
                    console.log('[前端Token計算] 成功取得Token');
                    return result.token;
                } else {
                    throw new Error(result.message || '後端計算Token失敗');
                }
            } catch (error) {
                console.error('[前端Token計算] 失敗:', error);
                return null;
            }
        }

        // 連接到OneNET
        async function connectToOneNET() {
            // 首先驗證設置
            const userID = document.getElementById('userID').value.trim();
            const userAccessKey = document.getElementById('userAccessKey').value.trim();
            const productID = document.getElementById('productID').value.trim();
            const deviceName = document.getElementById('deviceName').value.trim();
            const deviceKey = document.getElementById('deviceKey').value.trim();

            const errors = [];
            if (!userID) errors.push('User_ID');
            if (!userAccessKey) errors.push('User_AccessKey');
            if (!productID) errors.push('Product ID');
            if (!deviceName) errors.push('Device Name');
            if (!deviceKey) errors.push('Device Key');

            if (errors.length > 0) {
                showOneNETResponse('請填寫以下必填字段：' + errors.join(', '), 'error');
                return;
            }

            try {
                showOneNETResponse('正在連接到OneNET...', 'info');

                // 計算Token
                const token = await calculateOneNETToken(productID, deviceName, deviceKey);

                if (!token) {
                    throw new Error('Token計算失敗');
                }

                // 生成topic
                const topic = `$sys/${productID}/${deviceName}/thing/property/post`;

                // 準備請求體
                const requestBody = {
                    "id": "123",
                    "version": "1.0",
                    "params": {
                        "data": {
                            "value": "connection_test"
                        }
                    }
                };

                // 發送HTTP POST請求到本地代理服務器
                // 而不是直接調用OneNET（避免CORS問題）
                const proxyUrl = '/api/onenet/connect';  // 本地代理端點

                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        token: token,
                        topic: topic,
                        data: requestBody
                    })
                });

                const responseData = await response.json();
                const responseText = JSON.stringify(responseData, null, 2);

                if (response.ok && responseData.success) {
                    showOneNETResponse(`✓ 成功連接到OneNET!\n\n狀態碼: ${responseData.statusCode}\n回應內容:\n${responseText}`, 'success');

                    // 保存OneNET設置
                    const oneNetConfig = {
                        userID: userID,
                        userAccessKey: userAccessKey,
                        productID: productID,
                        deviceName: deviceName,
                        deviceKey: deviceKey,
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem('oneNetConfig', JSON.stringify(oneNetConfig));
                    addSerialLog('OneNET: 成功連接到OneNET', 'system');
                } else {
                    const errorMsg = responseData.message || '連接失敗';
                    showOneNETResponse(`✗ 連接失敗\n\n狀態碼: ${responseData.statusCode || 'unknown'}\n錯誤信息:\n${errorMsg}\n\n回應內容:\n${responseText}`, 'error');
                    addSerialLog(`OneNET連接失敗: ${errorMsg}`, 'error');
                }
            } catch (error) {
                console.error('OneNET連接錯誤:', error);
                showOneNETResponse(`✗ 連接錯誤: ${error.message}\n\n常見原因:\n1. 後端代理服務未啟動\n2. 檢查代理服務器地址是否正確\n3. 確保已正確填寫所有必填字段\n4. 檢查Product ID和Device Key是否正確\n\n請參考部署文檔以啟動後端代理服務。`, 'error');
                addSerialLog(`OneNET連接錯誤: ${error.message}`, 'error');
            }
        }

        // 斷開OneNET連接
        function disconnectFromOneNET() {
            // 清除保存的設置
            localStorage.removeItem('oneNetConfig');
            showOneNETResponse('✓ 已從OneNET斷開連接', 'info');
            addSerialLog('OneNET: 已斷開連接', 'system');

            // 清空輸入框
            document.getElementById('userID').value = '';
            document.getElementById('userAccessKey').value = '';
            document.getElementById('productID').value = '';
            document.getElementById('deviceName').value = '';
            document.getElementById('deviceKey').value = '';
            document.getElementById('imei').value = '';
            document.getElementById('imsi').value = '';

            // 1秒後隱藏回復框
            setTimeout(() => {
                document.getElementById('onenetResponseBox').classList.remove('show');
            }, 1000);
        }

        // 保存OneNET設置（保留此函數用於兼容性）
        function saveOneNETSettings() {
            connectToOneNET();
        }

        // 加載已保存的設置
        function loadSavedSettings() {
            // 加載OneNET設置
            const savedOneNetConfig = localStorage.getItem('oneNetConfig');
            if (savedOneNetConfig) {
                try {
                    const oneNetConfig = JSON.parse(savedOneNetConfig);
                    document.getElementById('userID').value = oneNetConfig.userID || '';
                    document.getElementById('userAccessKey').value = oneNetConfig.userAccessKey || '';
                    document.getElementById('productID').value = oneNetConfig.productID || '';
                    document.getElementById('deviceName').value = oneNetConfig.deviceName || '';
                    document.getElementById('deviceKey').value = oneNetConfig.deviceKey || '';
                    document.getElementById('imei').value = oneNetConfig.imei || '';
                    document.getElementById('imsi').value = oneNetConfig.imsi || '';
                } catch (e) {
                    console.error('Failed to load OneNET config:', e);
                }
            }
        }

        // 重置所有傳感器設置和GPIO選項
        function resetAllSettings() {
            // 二次確認，防止誤操作
            if (!confirm('確定要重置所有傳感器設置和GPIO選項嗎？此操作無法撤銷！')) {
                return;
            }

            if (!confirm('這是最後的確認：所有數據將被永久刪除。真的要繼續嗎？')) {
                return;
            }

            // 清除所有配置
            sensorConfig = {};
            gpioConfig = {};
            gpioConfirmStatus = {};
            usedGPIOs = {};
            sensorIdCounter = 0;
            gpioIdCounter = 0;

            // 清除本地存儲
            localStorage.removeItem('sensorConfig');
            localStorage.removeItem('usedGPIOs');
            localStorage.removeItem('sensorIdCounter');
            localStorage.removeItem('gpioConfig');
            localStorage.removeItem('gpioIdCounter');

            // 重新初始化UI
            updateSensorList();
            updateGPIOConfigList();
            initializeGPIOList();
            initializeGPIOOptions();

            // 顯示成功提示
            alert('已成功重置所有傳感器設置和GPIO選項。');
        }
    </script>
</body>

</html>