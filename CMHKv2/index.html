<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMHKv2 Web</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            color: #333;
        }

        .sidebar {
            width: 200px;
            position: fixed;
            left: 0;
            top: 0;
            background-color: #404040;
            height: 100vh;
            padding: 0;
            box-sizing: border-box;
            transition: width 0.3s ease, left 0.3s ease;
            font-family: 'Microsoft YaHei', '微软雅黑', 'SimHei', sans-serif;
            z-index: 999;
        }

        .sidebar.collapsed {
            width: 0;
            overflow: hidden;
        }

        .sidebar img {
            width: 100%;
            height: auto;
            display: block;
        }

        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar li {
            border-bottom: 1px solid white;
        }

        .sidebar a {
            display: block;
            padding: 15px;
            text-decoration: none;
            color: #ffffff;
            font-weight: bold;
        }

        .sidebar a:hover {
            background-color: #555555;
        }

        .toggle-btn {
            position: fixed;
            left: 200px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            z-index: 1000;
            transition: left 0.3s ease;
        }

        .toggle-btn::before {
            content: '';
            position: absolute;
            left: 0px;
            top: 50%;
            transform: translateY(-50%);
            width: 15px;
            height: 60px;
            background-color: #404040;
            clip-path: polygon(10% 0%, 100% 25%, 100% 75%, 10% 100%);
        }

        .toggle-btn::after {
            content: '';
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%) rotate(180deg);
            width: 0;
            height: 0;
            border-left: 5px solid #d3d3d3;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            transition: transform 0.3s ease;
        }

        .toggle-btn:hover::before {
            background-color: #bfbfbf;
        }

        .sidebar.collapsed~.toggle-btn {
            left: 0;
        }

        .sidebar.collapsed~.toggle-btn::after {
            transform: translateY(-50%);
        }

        .content {
            margin-left: 230px;
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        .content.expanded {
            margin-left: 30px;
        }

        .page {
            display: none;
        }

        .active {
            display: block;
        }

        /* 首頁樣式 */
        .homepage-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #000;
        }

        .homepage-subtitle {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #000;
        }

        /* 按鈕樣式 */
        .button-section {
            margin-bottom: 40px;
        }

        .connect-btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            color: white;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-family: 'SimHei', '黑體', sans-serif;
        }

        .connect-btn.connected {
            background-color: #dc3545;
        }

        .connect-btn.disconnected {
            background-color: #007bff;
        }

        .connect-btn:hover {
            opacity: 0.9;
        }

        /* 傳感器監控樣式 */
        .sensor-section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            color: #000;
        }

        .section-title::before {
            content: '';
            width: 12px;
            height: 12px;
            background-color: #000;
            margin-right: 10px;
        }

        .sensor-charts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .chart-container {
            background-color: #f0f0f0;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .chart-wrapper {
            position: relative;
            height: 250px;
        }

        /* GPIO 狀態樣式 */
        .gpio-section {
            margin-bottom: 40px;
        }

        .gpio-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .gpio-item {
            background-color: #f9f9f9;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .gpio-item-info {
            flex: 1;
        }

        .gpio-item-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .gpio-item-type {
            font-size: 12px;
            color: #666;
        }

        .gpio-item-value {
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: right;
        }

        .no-gpio {
            color: #999;
            font-style: italic;
            padding: 15px;
        }

        /* 串口日志样式 */
        .serial-log-section {
            margin-bottom: 40px;
        }

        .log-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .log-controls button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .log-controls button:hover {
            background-color: #0056b3;
        }

        .log-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .log-display {
            background-color: #1e1e1e;
            color: #00ff00;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #444;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .log-entry {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        .log-entry.send {
            color: #ffaa00;
        }

        .log-entry.receive {
            color: #00ff00;
        }

        .log-entry.error {
            color: #ff0000;
        }

        .log-entry.system {
            color: #aaaaaa;
        }

        .log-timestamp {
            color: #666666;
            margin-right: 8px;
        }

        .no-log {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 40px 15px;
        }

        /* 雙日志區域容器 */
        .dual-log-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .log-section-wrapper {
            display: flex;
            flex-direction: column;
        }

        .log-section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #000;
        }

        /* 傳感器配置頁面樣式 */
        .sensor-config-section {
            margin-bottom: 30px;
        }

        .sensor-config-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn-add {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-add:hover {
            background-color: #0056b3;
        }

        .btn-delete {
            background-color: #dc3545;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-delete:hover:not(:disabled) {
            background-color: #c82333;
        }

        .btn-delete:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-delete-row {
            background-color: #dc3545;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-delete-row:hover {
            background-color: #c82333;
        }

        /* 傳感器列表樣式 */
        .sensor-list-container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #ddd;
        }

        .sensor-list-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'SimHei', '黑體', sans-serif;
        }

        .sensor-list-table thead {
            background-color: #f0f0f0;
            border-bottom: 2px solid #ddd;
        }

        .sensor-list-table th {
            padding: 12px;
            text-align: left;
            font-weight: bold;
            color: #333;
        }

        .sensor-list-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }

        .sensor-list-table tbody tr:hover {
            background-color: #f5f5f5;
        }

        .sensor-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .no-sensor-message {
            text-align: center;
            padding: 30px;
            color: #999;
            font-style: italic;
        }

        /* 模態框樣式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            animation: fadeIn 0.3s ease;
        }

        .modal.show {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background-color: #ffffff;
            margin: 50px auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            box-sizing: border-box;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .required-mark {
            color: #dc3545;
            margin-left: 3px;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-confirm {
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-confirm:hover {
            background-color: #218838;
        }

        .btn-cancel {
            background-color: #6c757d;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-cancel:hover {
            background-color: #5a6268;
        }

        .error-message {
            color: #dc3545;
            font-size: 12px;
            margin-top: 3px;
        }

        .modal-status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            font-weight: 300;
            text-align: center;
            display: none;
        }

        .modal-status.show {
            display: block;
        }

        .modal-status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .modal-status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* 基本設置樣式 */
        .settings-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .settings-section h2 {
            color: #333;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .settings-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .settings-row:last-of-type {
            margin-bottom: 20px;
        }

        .settings-col {
            flex: 1;
        }

        /* 當只有一個列時 */
        .settings-row .settings-col:only-child {
            grid-column: 1;
        }

        /* WiFi回復消息樣式 */
        .wifi-response-box {
            margin-top: 15px;
            padding: 12px;
            border-radius: 4px;
            display: none;
            font-size: 14px;
        }

        .wifi-response-box.show {
            display: block;
        }

        .wifi-response-box.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .wifi-response-box.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .wifi-response-box.info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        /* OneNET回復消息樣式 */
        .onenet-response-box {
            margin-top: 15px;
            padding: 12px;
            border-radius: 4px;
            display: none;
            font-size: 14px;
        }

        .onenet-response-box.show {
            display: block;
        }

        .onenet-response-box.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .onenet-response-box.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .onenet-response-box.info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        /* 重置設置樣式 */
        .settings-reset-section {
            margin-top: 40px;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .settings-reset-section h2 {
            color: #333;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .reset-warning {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }

        .reset-warning p {
            margin: 0;
            font-size: 14px;
        }

        .btn-reset {
            background-color: #dc3545;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.3s ease;
        }

        .btn-reset:hover {
            background-color: #c82333;
        }

        .btn-reset:active {
            background-color: #bd2130;
        }

        /* GPIO 控制臺樣式 */
        .gpio-config-item {
            background-color: #f9f9f9;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .gpio-config-info {
            flex: 1;
        }

        .gpio-config-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .gpio-config-details {
            font-size: 12px;
            color: #666;
            display: flex;
            gap: 20px;
        }

        .gpio-config-status {
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: right;
        }

        /* GPIO 控制狀態表格樣式 */
        .gpio-control-container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #ddd;
        }

        .gpio-control-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'SimHei', '黑體', sans-serif;
        }

        .gpio-control-table thead {
            background-color: #f0f0f0;
            border-bottom: 2px solid #ddd;
        }

        .gpio-control-table th {
            padding: 12px;
            text-align: left;
            font-weight: bold;
            color: #333;
        }

        .gpio-control-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .gpio-control-table tbody tr:hover {
            background-color: #f5f5f5;
        }

        .no-gpio-message {
            text-align: center;
            color: #999;
            font-style: italic;
        }

        /* Digital 開關樣式 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            background-color: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .toggle-switch.on {
            background-color: #28a745;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.3s ease;
        }

        .toggle-switch.on::after {
            left: 28px;
        }

        /* Analog 滑塊樣式 */
        .analog-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .analog-slider {
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #ddd 0%, #ddd 100%);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .analog-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .analog-slider::-webkit-slider-thumb:hover {
            background: #0056b3;
        }

        .analog-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s ease;
        }

        .analog-slider::-moz-range-thumb:hover {
            background: #0056b3;
        }

        .analog-value {
            min-width: 40px;
            font-weight: bold;
            color: #000;
            font-size: 14px;
        }

        /* GPIO 操作欄樣式 */
        .gpio-action-cell {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-gpio-confirm {
            background-color: #007bff;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            font-family: 'SimHei', '黑體', sans-serif;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }

        .btn-gpio-confirm:hover {
            background-color: #0056b3;
        }

        .btn-gpio-confirm:active {
            background-color: #004085;
        }

        .gpio-confirm-status {
            font-size: 12px;
            color: #28a745;
            font-weight: bold;
            white-space: nowrap;
        }

        /* OneNET 回復框樣式 */
        .onenet-response-box {
            background-color: #f9f9f9;
            border: 2px solid #007bff;
            border-radius: 12px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 14px;
            color: #333;
            display: none;
            word-break: break-word;
            font-family: 'Courier New', monospace;
        }

        .onenet-response-box.show {
            display: block;
        }

        .onenet-response-box.success {
            border-color: #28a745;
            background-color: #f1f9f6;
            color: #155724;
        }

        .onenet-response-box.error {
            border-color: #dc3545;
            background-color: #fdf1f3;
            color: #721c24;
        }

        .onenet-response-box.info {
            border-color: #17a2b8;
            background-color: #f0f7fa;
            color: #0c5460;
        }
    </style>
</head>

<body>
    <div class="sidebar" id="sidebar">
        <img src="移動教育logo.png" alt="Logo">
        <ul>
            <li><a href="#" onclick="showPage('homepage')">首頁</a></li>
            <li><a href="#" onclick="showPage('sensorConfig')">傳感器配置</a></li>
            <li><a href="#" onclick="showPage('gpioControl')">GPIO控制台</a></li>
            <li><a href="#" onclick="showPage('aiChat')">AI對話</a></li>
            <li><a href="#" onclick="showPage('settings')">基本設置</a></li>
            <li><a href="#" onclick="showPage('serialLog')">串口日志</a></li>
        </ul>
    </div>
    <button class="toggle-btn" onclick="toggleSidebar()"></button>
    <div class="content" id="content">
        <div id="homepage" class="page active">
            <div class="homepage-title">眾智成城 V2 智能實驗探頭</div>
            <div class="homepage-subtitle">控制臺</div>

            <!-- 按鈕部分 -->
            <div class="button-section">
                <button class="connect-btn disconnected" id="connectBtn" onclick="handleDeviceConnection()">
                    連接設備
                </button>
            </div>

            <!-- 傳感器監控部分 -->
            <div class="sensor-section">
                <div class="section-title">傳感器監控</div>
                <div class="sensor-charts" id="sensorChartsContainer">
                    <!-- 傳感器圖表將在此呈現 -->
                    <div class="no-sensor">暫無傳感器數據</div>
                </div>
            </div>

            <!-- GPIO 狀態部分 -->
            <div class="gpio-section">
                <div class="section-title">GPIO 狀態</div>
                <div class="gpio-control-container">
                    <table class="gpio-control-table">
                        <thead>
                            <tr>
                                <th>GPIO名</th>
                                <th>類型</th>
                                <th>控制</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody id="gpioControlTableBody">
                            <tr>
                                <td colspan="4" class="no-gpio-message">暫無 GPIO 配置</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <div id="sensorConfig" class="page">
            <h1>傳感器配置</h1>
            <div class="sensor-config-section">
                <div class="sensor-config-actions">
                    <button class="btn-add" onclick="openAddSensorModal()">新增+</button>
                </div>
                <div class="sensor-list-container">
                    <table class="sensor-list-table">
                        <thead>
                            <tr>
                                <th>傳感器名稱</th>
                                <th>傳感器種類</th>
                                <th>GPIO</th>
                                <th>最後活躍時間</th>
                                <th style="width: 60px;">操作</th>
                            </tr>
                        </thead>
                        <tbody id="sensorListBody">
                            <tr>
                                <td colspan="5" class="no-sensor-message">暫無傳感器，請點擊"新增+"按鈕添加傳感器</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- 新增傳感器模態框 -->
        <div id="addSensorModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">新增傳感器</div>
                <div class="modal-status" id="modalStatus"></div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="sensorName">傳感器名稱：</label>
                        <input type="text" id="sensorName" placeholder="輸入傳感器名稱">
                        <div class="error-message" id="nameError"></div>
                    </div>
                    <div class="form-group">
                        <label for="sensorType">傳感器種類：</label>
                        <select id="sensorType">
                            <option value="">請選擇</option>
                            <option value="DHT11">DHT11</option>
                            <option value="analog">analog</option>
                            <option value="digital">digital</option>
                        </select>
                        <div class="error-message" id="typeError"></div>
                    </div>
                    <div class="form-group">
                        <label for="sensorGPIO">GPIO：</label>
                        <select id="sensorGPIO">
                            <option value="">請選擇</option>
                        </select>
                        <div class="error-message" id="gpioError"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-confirm" onclick="confirmAddSensor()">確定</button>
                    <button class="btn-cancel" onclick="closeAddSensorModal()">取消</button>
                </div>
            </div>
        </div>
        <div id="gpioControl" class="page">
            <h1>GPIO控制台</h1>
            <p>設置要把哪些GPIO作為output pin（不能使用傳感器已經使用的pin）。</p>
            <div class="sensor-config-section">
                <div class="sensor-config-actions">
                    <button class="btn-add" onclick="openAddGPIOModal()">新增+</button>
                </div>
                <div class="sensor-list-container">
                    <table class="sensor-list-table">
                        <thead>
                            <tr>
                                <th>GPIO名稱</th>
                                <th>GPIO Pin</th>
                                <th>輸出模式</th>
                                <th>狀態</th>
                                <th style="width: 60px;">操作</th>
                            </tr>
                        </thead>
                        <tbody id="gpioListBody">
                            <tr>
                                <td colspan="5" class="no-sensor-message">暫無GPIO配置，請點擊"新增+"按鈕添加GPIO</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- 新增GPIO模態框 -->
        <div id="addGPIOModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">新增GPIO</div>
                <div class="modal-status" id="gpioModalStatus"></div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="gpioName">GPIO名稱：</label>
                        <input type="text" id="gpioName" placeholder="輸入GPIO名稱">
                        <div class="error-message" id="gpioNameError"></div>
                    </div>
                    <div class="form-group">
                        <label for="gpioPin">GPIO Pin：</label>
                        <select id="gpioPin">
                            <option value="">請選擇</option>
                        </select>
                        <div class="error-message" id="gpioPinError"></div>
                    </div>
                    <div class="form-group">
                        <label for="gpioMode">輸出模式：</label>
                        <select id="gpioMode">
                            <option value="">請選擇</option>
                            <option value="digital">Digital</option>
                            <option value="analog">Analog</option>
                        </select>
                        <div class="error-message" id="gpioModeError"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-confirm" onclick="confirmAddGPIO()">確定</button>
                    <button class="btn-cancel" onclick="closeAddGPIOModal()">取消</button>
                </div>
            </div>
        </div>
        <div id="aiChat" class="page">
            <style>
                .ai-chat-header {
                    text-align: center;
                    margin-bottom: 20px;
                    padding: 20px;
                    background-color: rgba(255, 255, 255, 0.9);
                    border-radius: 12px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
                }

                .ai-chat-header h2 {
                    color: #2c3e50;
                    margin-bottom: 8px;
                    font-size: 2rem;
                }

                .ai-chat-header p {
                    color: #546e7a;
                    font-size: 1rem;
                    max-width: 800px;
                    margin: 0 auto;
                    line-height: 1.6;
                }

                .ai-chat-container {
                    display: flex;
                    flex-direction: column;
                    flex: 1;
                    background-color: rgba(255, 255, 255, 0.9);
                    border-radius: 12px;
                    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
                    overflow: hidden;
                    min-height: 800px;
                }

                .iframe-container {
                    flex: 1;
                    position: relative;
                    min-height: 800px;
                }

                .iframe-container iframe {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    border: none;
                }

                .loading-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: #f8f9fa;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 10;
                    transition: opacity 0.3s ease;
                }

                .loading-spinner {
                    width: 50px;
                    height: 50px;
                    border: 5px solid #e0e0e0;
                    border-top: 5px solid #3498db;
                    border-radius: 50%;
                    animation: spin 1s linear infinite;
                    margin-bottom: 20px;
                }

                @keyframes spin {
                    0% {
                        transform: rotate(0deg);
                    }

                    100% {
                        transform: rotate(360deg);
                    }
                }

                .ai-chat-controls {
                    padding: 15px 20px;
                    background-color: #f8f9fa;
                    border-top: 1px solid #eaeaea;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    flex-wrap: wrap;
                    gap: 10px;
                }

                .info-text {
                    color: #546e7a;
                    font-size: 0.95rem;
                }

                .ai-chat-btn {
                    padding: 10px 20px;
                    background-color: #3498db;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s ease;
                }

                .ai-chat-btn:hover {
                    background-color: #2980b9;
                    transform: translateY(-2px);
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                }

                .ai-chat-btn:active {
                    transform: translateY(0);
                }

                .btn-refresh {
                    background-color: #2ecc71;
                }

                .btn-refresh:hover {
                    background-color: #27ae60;
                }

                .btn-fullscreen {
                    background-color: #9b59b6;
                }

                .btn-fullscreen:hover {
                    background-color: #8e44ad;
                }

                .ai-chat-footer {
                    margin-top: 20px;
                    text-align: center;
                    color: #7f8c8d;
                    font-size: 0.9rem;
                    padding: 15px;
                }

                .ai-chat-footer a {
                    color: #3498db;
                    text-decoration: none;
                }

                .ai-chat-footer a:hover {
                    text-decoration: underline;
                }

                .button-group {
                    display: flex;
                    gap: 10px;
                    justify-content: flex-end;
                }
            </style>

            <!-- <div class="ai-chat-header">
                <h2>AI對話</h2>
                <p></p>
            </div> -->

            <div class="ai-chat-container">
                <div class="iframe-container">
                    <div class="loading-overlay" id="loadingOverlay">
                        <div class="loading-spinner"></div>
                        <p>正在加載FastGPT聊天界面...</p>
                    </div>
                    <iframe id="fastgptIframe"
                        src="https://cloud.fastgpt.io/chat/share?shareId=uxNyAoAdnEMT9HzPP5jioCug&showHistory=0"
                        title="FastGPT聊天助手"></iframe>
                </div>

                <div class="ai-chat-controls">
                    <div class="info-text">
                        AI聊天助手 | 歷史記錄: 隱藏
                    </div>
                    <div class="button-group">
                        <button class="ai-chat-btn btn-refresh" id="refreshBtn">刷新頁面</button>
                        <button class="ai-chat-btn btn-fullscreen" id="fullscreenBtn">全屏顯示</button>
                    </div>
                </div>
            </div>

            <div class="ai-chat-footer">
                <p>本頁面嵌入 <a href="https://cloud.fastgpt.io" target="_blank">FastGPT</a> 聊天界面 | 僅供演示使用</p>
            </div>

            <script>
                document.addEventListener('DOMContentLoaded', function () {
                    const iframe = document.getElementById('fastgptIframe');
                    const loadingOverlay = document.getElementById('loadingOverlay');
                    const refreshBtn = document.getElementById('refreshBtn');
                    const fullscreenBtn = document.getElementById('fullscreenBtn');
                    const container = document.querySelector('.ai-chat-container');

                    // 當iframe加載完成後隱藏加載動畫
                    if (iframe) {
                        iframe.addEventListener('load', function () {
                            setTimeout(() => {
                                if (loadingOverlay) {
                                    loadingOverlay.style.opacity = '0';
                                    setTimeout(() => {
                                        loadingOverlay.style.display = 'none';
                                    }, 300);
                                }
                            }, 500); // 延遲500ms確保內容完全加載
                        });
                    }

                    // 刷新按鈕功能
                    if (refreshBtn) {
                        refreshBtn.addEventListener('click', function () {
                            if (loadingOverlay) {
                                loadingOverlay.style.display = 'flex';
                                loadingOverlay.style.opacity = '1';
                            }
                            if (iframe) {
                                iframe.src = iframe.src; // 重新加載iframe
                            }
                        });
                    }

                    // 全屏功能
                    if (fullscreenBtn) {
                        fullscreenBtn.addEventListener('click', function () {
                            if (!document.fullscreenElement) {
                                if (container.requestFullscreen) {
                                    container.requestFullscreen();
                                } else if (container.webkitRequestFullscreen) {
                                    container.webkitRequestFullscreen();
                                } else if (container.msRequestFullscreen) {
                                    container.msRequestFullscreen();
                                }
                                fullscreenBtn.textContent = '退出全屏';
                            } else {
                                if (document.exitFullscreen) {
                                    document.exitFullscreen();
                                } else if (document.webkitExitFullscreen) {
                                    document.webkitExitFullscreen();
                                } else if (document.msExitFullscreen) {
                                    document.msExitFullscreen();
                                }
                                fullscreenBtn.textContent = '全屏顯示';
                            }
                        });
                    }

                    // 監聽全屏狀態變化
                    document.addEventListener('fullscreenchange', handleFullscreenChange);
                    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                    document.addEventListener('msfullscreenchange', handleFullscreenChange);

                    function handleFullscreenChange() {
                        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                            if (fullscreenBtn) {
                                fullscreenBtn.textContent = '全屏顯示';
                            }
                        }
                    }

                    // 如果iframe加載失敗
                    if (iframe) {
                        iframe.addEventListener('error', function () {
                            if (loadingOverlay) {
                                loadingOverlay.innerHTML = `
                                    <div style="text-align: center; color: #e74c3c;">
                                        <h3>加載失敗</h3>
                                        <p>無法加載FastGPT聊天界面，請檢查網絡連接或稍後重試。</p>
                                        <button class="ai-chat-btn" style="margin-top: 15px;" onclick="location.reload()">重新加載</button>
                                    </div>
                                `;
                            }
                        });
                    }
                });
            </script>
        </div>
        <div id="settings" class="page">
            <h1>基本設置</h1>

            <!-- WiFi設置區域 -->
            <div class="settings-section">
                <h2>WiFi</h2>
                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="wifiSSID">SSID <span class="required-mark">*</span></label>
                            <input type="text" id="wifiSSID" placeholder="輸入WiFi SSID">
                            <div class="error-message" id="wifiSSIDError"></div>
                        </div>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="wifiPassword">Password <span class="required-mark">*</span></label>
                            <input type="password" id="wifiPassword" placeholder="輸入WiFi密碼">
                            <div class="error-message" id="wifiPasswordError"></div>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="btn-confirm" onclick="saveWiFiSettings()">確定</button>
                    <button class="btn-confirm" onclick="connectWiFi()" style="background-color: #17a2b8;">連接</button>
                    <button class="btn-cancel" onclick="clearWiFiSettings()">清除設置</button>
                </div>
                <div class="wifi-response-box" id="wifiResponseBox">
                    <!-- WiFi回復信息将在這裡顯示 -->
                </div>
            </div>

            <!-- OneNET設置區域 -->
            <div class="settings-section">
                <h2>OneNET</h2>
                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="userID">User_ID <span class="required-mark">*</span></label>
                            <input type="text" id="userID" placeholder="輸入User ID">
                        </div>
                    </div>
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="userAccessKey">User_AccessKey <span class="required-mark">*</span></label>
                            <input type="text" id="userAccessKey" placeholder="輸入User AccessKey">
                        </div>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="productID">Product ID <span class="required-mark">*</span></label>
                            <input type="text" id="productID" placeholder="輸入Product ID">
                        </div>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="deviceName">Device Name <span class="required-mark">*</span></label>
                            <input type="text" id="deviceName" placeholder="輸入Device Name">
                        </div>
                    </div>
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="deviceKey">Device Key <span class="required-mark">*</span></label>
                            <input type="text" id="deviceKey" placeholder="輸入Device Key">
                        </div>
                    </div>
                </div>

                <div class="settings-row">
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="imei">IMEI</label>
                            <input type="text" id="imei" placeholder="輸入IMEI">
                        </div>
                    </div>
                    <div class="settings-col">
                        <div class="form-group">
                            <label for="imsi">IMSI</label>
                            <input type="text" id="imsi" placeholder="輸入IMSI">
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="btn-confirm" onclick="saveOneNETSettings()">確定</button>
                    <button class="btn-confirm" onclick="connectOneNET()" style="background-color: #17a2b8;">連接</button>
                    <button class="btn-cancel" onclick="clearOneNETSettings()">清除設置</button>
                </div>
                <div class="onenet-response-box" id="onenetResponseBox">
                    <!-- OneNET回復信息将在這裡顯示 -->
                </div>
            </div>

            <!-- 重置傳感器設置區域 -->
            <div class="settings-reset-section">
                <h2>重置設置</h2>
                <div class="reset-warning">
                    <p><strong>警告：</strong>點擊下方按鈕將清除所有已創建的傳感器和GPIO配置。此操作無法撤銷！</p>
                </div>
                <button class="btn-reset" onclick="resetAllSettings()">重置所有傳感器設置和GPIO選項</button>
            </div>
        </div>
        <div id="serialLog" class="page">
            <h1>串口日志</h1>
            <div class="serial-log-section">
                <div class="log-controls">
                    <button id="clearLogBtn" onclick="clearSerialLog()">清空日志</button>
                    <button id="exportLogBtn" onclick="exportSerialLog()">匯出日志</button>
                    <label style="margin-left: 20px; font-weight: bold;">
                        <input type="checkbox" id="autoScrollCheckbox" checked onchange="toggleAutoScroll()"> 自動滾動
                    </label>
                </div>
                <div class="dual-log-container">
                    <div class="log-section-wrapper">
                        <div class="log-section-title">傳感器日志</div>
                        <div class="log-display" id="logDisplay">
                            <div class="no-log">等待連接設備並接收數據...</div>
                        </div>
                    </div>
                    <div class="log-section-wrapper">
                        <div class="log-section-title">軟串口日志 [soft]</div>
                        <div class="log-display" id="softLogDisplay">
                            <div class="no-log">等待連接設備並接收數據...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // 全局狀態管理
        let deviceConnected = false;
        // BLE 相關
        let bleDevice = null;
        let txCharacteristic = null; // 寫入（TX）
        let rxCharacteristic = null; // 接收通知（RX）
        // Nordic UART Service UUID (Gyro_LSM6DS3TR 設備)
        const BLE_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const BLE_TX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // notify (device -> central)
        const BLE_RX_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // write   (central -> device)
        let charts = {}; // 動態圖表 {sensorName: chartInstance}
        let sensorDataMap = {}; // 傳感器數據 {sensorName: {unit, data: []}}
        let sensorConfig = {}; // 傳感器配置 {id: {name, type, gpio, lastActive}}
        let gpioConfig = {}; // GPIO 配置 {id: {name, pin, mode, status}}
        let serialLogHistory = []; // 串口日志歷史
        let autoScroll = true; // 自動滾動標記
        let usedGPIOs = {}; // 已使用的GPIO {io: sensorId}
        let sensorIdCounter = 0; // 傳感器ID計數器
        let gpioIdCounter = 0; // GPIO ID計數器
        let gpioConfirmStatus = {}; // GPIO 確認狀態 {gpioId: {pin, confirmed, value}}
        let serialReceiveBuffer = ''; // 接收缓冲区（兼容串行/藍牙分片）
        let colorPalette = ['#dc3545', '#007bff', '#28a745', '#ffc107', '#17a2b8', '#fd7e14', '#6f42c1', '#20c997']; // 圖表顏色調色板
        let colorIndex = 0; // 顏色索引
        let pendingDHT11Config = {}; // 待創建的DHT11傳感器 {gpio: {sensorId, name, type, gpio}}
        let pendingDHT11Delete = {}; // 待刪除的DHT11傳感器 {gpio: sensorId}

        // 處理設備連接（改為使用藍牙）
        async function handleDeviceConnection() {
            if (deviceConnected) {
                await disconnectDevice();
            } else {
                await connectDevice();
            }
        }

        // 連接設備（使用 Web Bluetooth，基於 NUS-like TX/RX）
        async function connectDevice() {
            try {
                // 如果已連接，先斷開舊連接
                if (deviceConnected || bleDevice) {
                    await disconnectDevice();
                    await new Promise(resolve => setTimeout(resolve, 500)); // 等待 500ms 釋放資源
                }

                addSerialLog('系統: 嘗試通過藍牙連接設備...', 'system');

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'Gyro_LSM6DS3TR' }],
                    optionalServices: [BLE_SERVICE_UUID]
                });

                const server = await bleDevice.gatt.connect();

                // 等待 GATT 服務器完全初始化
                await new Promise(resolve => setTimeout(resolve, 300));

                // 確保連接仍然有效
                if (!bleDevice.gatt.connected) {
                    throw new Error('GATT 連接在初始化期間斷開');
                }

                const service = await server.getPrimaryService(BLE_SERVICE_UUID);

                // 獲取 RX (write) 和 TX (notify) 特徵
                try {
                    rxCharacteristic = await service.getCharacteristic(BLE_RX_UUID); // write
                    console.log('RX characteristic found:', BLE_RX_UUID);
                } catch (e) {
                    console.error('無法獲取 RX 特徵:', e);
                    rxCharacteristic = null;
                }
                try {
                    txCharacteristic = await service.getCharacteristic(BLE_TX_UUID); // notify
                    console.log('TX characteristic found:', BLE_TX_UUID);
                } catch (e) {
                    console.error('無法獲取 TX 特徵:', e);
                    txCharacteristic = null;
                }

                if (txCharacteristic) {
                    // 先綁定事件監聽器，再啟動通知
                    txCharacteristic.addEventListener('characteristicvaluechanged', handleBLENotification);
                    console.log('已綁定 characteristicvaluechanged 事件監聽器');

                    // 同時使用 oncharacteristicvaluechanged 屬性作為備份
                    txCharacteristic.oncharacteristicvaluechanged = handleBLENotification;
                    console.log('已設置 oncharacteristicvaluechanged 屬性');

                    await txCharacteristic.startNotifications();
                    console.log('已啟動 TX 特徵通知');
                    addSerialLog('系統: TX 通知已啟用', 'system');
                    addSerialLog('系統: 等待設備數據...', 'system');
                }

                // 設置斷開事件監聽
                setupBLEDisconnectHandler();
                deviceConnected = true;
                serialReceiveBuffer = '';
                addSerialLog('系統: 藍牙連接成功', 'system');
                updateConnectButton();

            } catch (error) {
                console.error('藍牙連接失敗:', error);
                addSerialLog('錯誤: ' + error.message, 'error');
                alert('連接失敗: ' + error.message);
                deviceConnected = false;
                updateConnectButton();
            }
        }

        // 處理藍牙通知數據
        function handleBLENotification(event) {
            try {
                console.log('✓ BLE通知事件已觸發', event);
                const value = event.target.value;
                console.log('原始數據（DataView）:', value);
                console.log('數據長度:', value.byteLength);

                const decoder = new TextDecoder();
                const dataChunk = decoder.decode(value);
                console.log('解碼後的數據:', JSON.stringify(dataChunk));
                console.log('解碼後的數據長度:', dataChunk.length);

                // 添加到緩衝區
                serialReceiveBuffer += dataChunk;
                console.log('當前緩衝區內容:', JSON.stringify(serialReceiveBuffer));

                // 處理緩衝區中的完整消息（以 $ 標志作為分割符）
                let processedMessages = 0;
                while (true) {
                    // 查找 $
                    const messageStartIndex = serialReceiveBuffer.indexOf('$');

                    if (messageStartIndex === -1) {
                        // 沒有找到 $，等待更多數據
                        console.log('沒有找到 $ 標志，等待更多數據');
                        break;
                    }

                    if (messageStartIndex > 0) {
                        // 丟棄 $ 前的垃圾數據
                        console.log('丟棄垃圾數據:', JSON.stringify(serialReceiveBuffer.substring(0, messageStartIndex)));
                        serialReceiveBuffer = serialReceiveBuffer.substring(messageStartIndex);
                    }

                    // 查找下一個 $ 或換行符作為消息結尾
                    let nextDelimiterIndex = -1;
                    let nextDelimiterType = ''; // 'dollar' 或 'newline'

                    const nextDollarIndex = serialReceiveBuffer.indexOf('$', 1);
                    const crlfIndex = serialReceiveBuffer.indexOf('\r\n', 1);
                    const lfIndex = serialReceiveBuffer.indexOf('\n', 1);
                    const crIndex = serialReceiveBuffer.indexOf('\r', 1);

                    // 找到最近的分割點
                    const delimiters = [];
                    if (nextDollarIndex !== -1) delimiters.push({ index: nextDollarIndex, type: 'dollar' });
                    if (crlfIndex !== -1) delimiters.push({ index: crlfIndex, type: 'crlf' });
                    if (lfIndex !== -1 && lfIndex !== crlfIndex) delimiters.push({ index: lfIndex, type: 'lf' });
                    if (crIndex !== -1 && crIndex !== crlfIndex) delimiters.push({ index: crIndex, type: 'cr' });

                    if (delimiters.length === 0) {
                        // 沒有找到消息結尾，等待更多數據
                        console.log('沒有找到消息結尾，等待更多數據');
                        break;
                    }

                    // 選擇最近的分割點
                    delimiters.sort((a, b) => a.index - b.index);
                    const delimiter = delimiters[0];
                    nextDelimiterIndex = delimiter.index;
                    nextDelimiterType = delimiter.type;

                    // 提取完整的消息（不包括 $ 和結尾符）
                    let message = serialReceiveBuffer.substring(1, nextDelimiterIndex).trim();

                    // 計算要移除的字符數
                    let moveForwardLength = nextDelimiterIndex;
                    if (nextDelimiterType === 'crlf') {
                        moveForwardLength += 2;
                    } else if (nextDelimiterType === 'lf' || nextDelimiterType === 'cr') {
                        moveForwardLength += 1;
                    } else if (nextDelimiterType === 'dollar') {
                        moveForwardLength += 1;
                    }

                    serialReceiveBuffer = serialReceiveBuffer.substring(moveForwardLength);

                    if (message.length > 0) {
                        console.log('處理消息 [' + processedMessages + ']:', message);
                        addSerialLog(message, 'receive');
                        handleGPIOConfirmation(message);
                        handleDHT11Confirmation(message);
                        processSensorData(message);
                        processedMessages++;
                    }
                }

                if (processedMessages > 0) {
                    console.log('本次通知共處理了 ' + processedMessages + ' 條消息');
                }
            } catch (e) {
                console.error('處理BLE通知失敗:', e);
                console.error('錯誤堆棧:', e.stack);
                addSerialLog('錯誤: 處理BLE通知失敗 - ' + e.message, 'error');
            }
        }

        // 斷開藍牙連接
        async function disconnectDevice() {
            try {
                // 停止接收通知（TX characteristic）
                if (txCharacteristic) {
                    try {
                        await txCharacteristic.stopNotifications();
                        txCharacteristic.removeEventListener('characteristicvaluechanged', handleBLENotification);
                    } catch (e) {
                        console.error('停止 TX 通知失敗:', e);
                    }
                }

                // 斷開 GATT 連接
                if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected) {
                    try {
                        await bleDevice.gatt.disconnect();
                        console.log('GATT 連接已斷開');
                    } catch (e) {
                        console.error('GATT 斷開失敗:', e);
                    }
                }

                // 移除斷開連接監聽器
                if (bleDevice) {
                    try {
                        bleDevice.removeEventListener('gattserverdisconnected', handleBLEDisconnect);
                    } catch (e) {
                        // ignore
                    }
                }

                // 重置所有狀態
                deviceConnected = false;
                bleDevice = null;
                txCharacteristic = null;
                rxCharacteristic = null;
                serialReceiveBuffer = '';

                addSerialLog('系統: 設備已斷開連接', 'system');
                updateConnectButton();
            } catch (error) {
                console.error('斷開藍牙失敗:', error);
                addSerialLog('錯誤: ' + error.message, 'error');
                // 確保狀態被重置
                deviceConnected = false;
                bleDevice = null;
                txCharacteristic = null;
                rxCharacteristic = null;
                updateConnectButton();
            }
        }

        // 更新連接按鈕狀態
        function updateConnectButton() {
            const btn = document.getElementById('connectBtn');
            if (deviceConnected) {
                btn.classList.remove('disconnected');
                btn.classList.add('connected');
                btn.textContent = '斷開連接';
            } else {
                btn.classList.remove('connected');
                btn.classList.add('disconnected');
                btn.textContent = '連接設備';
            }
        }

        // 處理傳感器數據 - 解析格式: [sensor][name][unit]=value
        function processSensorData(data) {
            try {
                // 匹配格式: [sensor][sensorName][unit]=value
                // 改進的正則表達式，支持更多浮點數格式
                const match = data.match(/\[sensor\]\[([^\]]+)\]\[([^\]]+)\]=(-?[\d.]+(?:[eE][+-]?\d+)?)/);
                if (!match) {
                    console.log('非傳感器數據或格式不匹配:', data);
                    return;
                }

                const sensorName = match[1]; // 例如: 'ax', 'ay', 'az', 'gx', 'gy', 'gz', 'g'
                const unit = match[2];       // 例如: 'g', 'dps', 'm/s²'
                const value = parseFloat(match[3]); // 數值

                console.log('傳感器數據已解析: 名稱=' + sensorName + ', 單位=' + unit + ', 值=' + value);

                // 初始化傳感器數據（如果不存在）
                if (!sensorDataMap[sensorName]) {
                    sensorDataMap[sensorName] = {
                        unit: unit,
                        data: [],
                        timestamps: []
                    };
                    // 為新傳感器創建圖表
                    createSensorChart(sensorName, unit);
                }

                // 添加新數據點
                const now = new Date();
                const timeString = now.toLocaleTimeString('zh-HK', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                sensorDataMap[sensorName].data.push(value);
                sensorDataMap[sensorName].timestamps.push(timeString);

                // 限制數據點數量（只保留最近 40 個點）
                const maxDataPoints = 40;
                if (sensorDataMap[sensorName].data.length > maxDataPoints) {
                    sensorDataMap[sensorName].data.shift();
                    sensorDataMap[sensorName].timestamps.shift();
                }

                // 更新圖表
                if (charts[sensorName]) {
                    const chart = charts[sensorName];
                    chart.data.labels = sensorDataMap[sensorName].timestamps;
                    chart.data.datasets[0].data = sensorDataMap[sensorName].data;
                    chart.update('none'); // 使用 'none' 避免過多的重繪動畫
                }
            } catch (error) {
                console.error('處理傳感器數據出錯:', error);
            }
        }

        // 創建傳感器圖表
        function createSensorChart(sensorName, unit) {
            const container = document.getElementById('sensorChartsContainer');

            // 如果容器是空的或有提示信息，先清空
            if (container.innerHTML.includes('no-sensor') || Object.keys(charts).length === 0) {
                container.innerHTML = '';
            }

            // 創建圖表容器
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.id = `chart-container-${sensorName}`;

            const chartTitle = document.createElement('div');
            chartTitle.className = 'chart-title';
            chartTitle.textContent = `${sensorName} (${unit})`;

            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'chart-wrapper';

            const canvas = document.createElement('canvas');
            canvas.id = `chart-${sensorName}`;

            canvasWrapper.appendChild(canvas);
            chartContainer.appendChild(chartTitle);
            chartContainer.appendChild(canvasWrapper);
            container.appendChild(chartContainer);

            // 選擇顏色
            const color = colorPalette[colorIndex % colorPalette.length];
            colorIndex++;

            // 創建 Chart.js 圖表
            const ctx = canvas.getContext('2d');
            charts[sensorName] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: sensorName,
                        data: [],
                        borderColor: color,
                        backgroundColor: color + '1a', // 10% 透明度
                        tension: 0.4,
                        fill: true,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointBackgroundColor: color
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false
                        }
                    }
                }
            });

            console.log(`創建圖表: ${sensorName}`);
        }

        // 初始化 GPIO 列表（首頁GPIO狀態，用表格顯示）
        function initializeGPIOList() {
            const tbody = document.getElementById('gpioControlTableBody');

            // 如果沒有配置，顯示提示信息
            if (Object.keys(gpioConfig).length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="no-gpio-message">暫無 GPIO 配置。請在"GPIO控制臺"中配置。</td></tr>';
                return;
            }

            tbody.innerHTML = '';

            // 顯示每個 GPIO 的狀態
            for (const [gpioId, config] of Object.entries(gpioConfig)) {
                const row = document.createElement('tr');
                row.id = `gpio-row-${gpioId}`;

                // GPIO 名稱列
                const nameCell = document.createElement('td');
                nameCell.textContent = escapeHtml(config.name);

                // 類型列
                const typeCell = document.createElement('td');
                typeCell.textContent = config.mode === 'digital' ? 'Digital' : 'Analog';

                // 控制列
                const controlCell = document.createElement('td');
                controlCell.id = `gpio-control-${gpioId}`;

                if (config.mode === 'digital') {
                    // Digital: 開關
                    const toggle = document.createElement('div');
                    toggle.className = `toggle-switch ${config.status === 'HIGH' ? 'on' : ''}`;
                    toggle.id = `toggle-${gpioId}`;
                    toggle.onclick = () => toggleDigitalGPIO(gpioId);
                    controlCell.appendChild(toggle);
                } else {
                    // Analog: 滑塊
                    const container = document.createElement('div');
                    container.className = 'analog-slider-container';

                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.min = '0';
                    slider.max = '255';
                    slider.value = parseInt(config.status) || 0;
                    slider.className = 'analog-slider';
                    slider.id = `slider-${gpioId}`;
                    slider.oninput = () => updateAnalogGPIO(gpioId, slider.value);

                    const valueDisplay = document.createElement('span');
                    valueDisplay.className = 'analog-value';
                    valueDisplay.id = `value-${gpioId}`;
                    valueDisplay.textContent = parseInt(config.status) || 0;

                    container.appendChild(slider);
                    container.appendChild(valueDisplay);
                    controlCell.appendChild(container);
                }

                // 操作列（確定按鈕和確認狀態）
                const actionCell = document.createElement('td');
                actionCell.id = `gpio-action-${gpioId}`;
                actionCell.className = 'gpio-action-cell';

                const confirmBtn = document.createElement('button');
                confirmBtn.className = 'btn-gpio-confirm';
                confirmBtn.textContent = '確定';
                confirmBtn.onclick = () => confirmGPIOValue(gpioId);

                const statusSpan = document.createElement('span');
                statusSpan.id = `gpio-status-${gpioId}`;
                statusSpan.className = 'gpio-confirm-status';

                // 如果已經確認過，顯示確認狀態
                if (gpioConfirmStatus[gpioId] && gpioConfirmStatus[gpioId].confirmed) {
                    statusSpan.textContent = `當前${config.pin}=${gpioConfirmStatus[gpioId].value}`;
                }

                actionCell.appendChild(confirmBtn);
                actionCell.appendChild(statusSpan);

                row.appendChild(nameCell);
                row.appendChild(typeCell);
                row.appendChild(controlCell);
                row.appendChild(actionCell);
                tbody.appendChild(row);
            }
        }

        // 切換 Digital GPIO
        function toggleDigitalGPIO(gpioId) {
            if (gpioConfig[gpioId]) {
                const currentStatus = gpioConfig[gpioId].status;
                gpioConfig[gpioId].status = currentStatus === 'HIGH' ? 'LOW' : 'HIGH';

                // 更新toggle開關的狀態
                const toggle = document.getElementById(`toggle-${gpioId}`);
                if (toggle) {
                    toggle.classList.toggle('on');
                }

                // 保存配置
                saveGPIOConfig();

                // 發送數據給設備（如果連接了）
                if (deviceConnected) {
                    sendGPIOCommand(gpioId, gpioConfig[gpioId].status);
                }
            }
        }

        // 更新 Analog GPIO
        function updateAnalogGPIO(gpioId, value) {
            if (gpioConfig[gpioId]) {
                gpioConfig[gpioId].status = value.toString();

                // 更新數值顯示
                const valueDisplay = document.getElementById(`value-${gpioId}`);
                if (valueDisplay) {
                    valueDisplay.textContent = value;
                }

                // 保存配置
                saveGPIOConfig();

                // 發送數據給設備（如果連接了）
                if (deviceConnected) {
                    sendGPIOCommand(gpioId, value);
                }
            }
        }

        // 發送GPIO命令給設備（通過 BLE RX 特徵 write）
        async function sendGPIOCommand(gpioId, value) {
            if (!deviceConnected || !rxCharacteristic) return;

            try {
                const config = gpioConfig[gpioId];
                const command = JSON.stringify({
                    cmd: 'gpio_control',
                    gpio: config.pin,
                    mode: config.mode,
                    value: value
                });

                const encoder = new TextEncoder();
                await rxCharacteristic.writeValue(encoder.encode(command + '\n'));

                addSerialLog(`發送GPIO命令: ${command}`, 'send');
            } catch (error) {
                console.error('發送GPIO命令失敗:', error);
                addSerialLog('錯誤: 發送GPIO命令失敗 - ' + error.message, 'error');
            }
        }

        // 發送DHT11添加命令給設備（通過 BLE RX）
        async function sendDHT11AddCommand(gpio) {
            if (!deviceConnected || !rxCharacteristic) return;

            try {
                const command = `AT+ADDDHT11=${gpio}`;
                const encoder = new TextEncoder();
                await rxCharacteristic.writeValue(encoder.encode(command + '\r\n'));

                addSerialLog(`發送DHT11添加命令: ${command}`, 'send');
            } catch (error) {
                console.error('發送DHT11添加命令失敗:', error);
                addSerialLog('錯誤: 發送DHT11添加命令失敗 - ' + error.message, 'error');
            }
        }

        // 發送DHT11刪除命令給設備（通過 BLE RX）
        async function sendDHT11DeleteCommand(gpio) {
            if (!deviceConnected || !rxCharacteristic) return;

            try {
                const command = `AT+DELDHT11=${gpio}`;
                const encoder = new TextEncoder();
                await rxCharacteristic.writeValue(encoder.encode(command + '\r\n'));

                addSerialLog(`發送DHT11刪除命令: ${command}`, 'send');
            } catch (error) {
                console.error('發送DHT11刪除命令失敗:', error);
                addSerialLog('錯誤: 發送DHT11刪除命令失敗 - ' + error.message, 'error');
            }
        }

        // 更新 GPIO 狀態（來自設備數據）
        function updateGPIOStatus(gpioId, value) {
            if (gpioConfig[gpioId]) {
                gpioConfig[gpioId].status = value;
                initializeGPIOList(); // 重新渲染列表
            }
        }

        // 確認 GPIO 值（發送AT命令給設備）
        async function confirmGPIOValue(gpioId) {
            if (!deviceConnected || !rxCharacteristic) {
                alert('請先連接設備');
                return;
            }

            const config = gpioConfig[gpioId];
            if (!config) return;

            try {
                // 構建AT命令格式
                let value;
                if (config.mode === 'digital') {
                    value = config.status === 'HIGH' ? 1 : 0;
                } else {
                    value = parseInt(config.status) || 0;
                }

                const command = `AT+${config.pin}=${value}`;

                // 發送命令（BLE RX）
                const encoder = new TextEncoder();
                try {
                    await rxCharacteristic.writeValue(encoder.encode(command + '\r\n'));
                    addSerialLog(`發送GPIO確定命令: ${command}`, 'send');
                } catch (e) {
                    console.error('發送GPIO確定命令透過BLE失敗:', e);
                    addSerialLog('錯誤: 發送GPIO確定命令失敗 - ' + e.message, 'error');
                }

                // 設置等待確認的狀態
                gpioConfirmStatus[gpioId] = {
                    pin: config.pin,
                    confirmed: false,
                    value: value,
                    timestamp: Date.now()
                };

                // 60秒後如果還沒收到確認，則超時
                setTimeout(() => {
                    if (gpioConfirmStatus[gpioId] && !gpioConfirmStatus[gpioId].confirmed) {
                        addSerialLog(`警告: ${config.pin} 設置超時（60秒內無回復）`, 'error');
                        delete gpioConfirmStatus[gpioId];
                    }
                }, 60000);

            } catch (error) {
                console.error('發送GPIO確定命令失敗:', error);
                addSerialLog('錯誤: 發送GPIO確定命令失敗 - ' + error.message, 'error');
            }
        }

        // 處理設備回復的GPIO設置確認
        function handleGPIOConfirmation(message) {
            // 匹配格式 "[设置]IO2=100" 或 "[設置]IO2=100"
            const confirmPattern = /\[.*?\](IO\d+)=(\d+)/;
            const match = message.match(confirmPattern);

            if (match) {
                const pin = match[1];
                const value = match[2];

                // 查找對應的gpioId
                for (const [gpioId, config] of Object.entries(gpioConfig)) {
                    if (config.pin === pin) {
                        gpioConfirmStatus[gpioId] = {
                            pin: pin,
                            confirmed: true,
                            value: value,
                            timestamp: Date.now()
                        };

                        // 更新UI顯示確認狀態
                        const statusSpan = document.getElementById(`gpio-status-${gpioId}`);
                        if (statusSpan) {
                            statusSpan.textContent = `當前${pin}=${value}`;
                        }

                        addSerialLog(`GPIO 設置確認: ${pin}=${value}`, 'receive');
                        break;
                    }
                }
            }
        }

        // 處理設備回復的DHT11確認
        function handleDHT11Confirmation(message) {
            // 匹配格式 "[DHT] 已添加DHT11: *GPIO*" 或 "[DHT] 已添加DHT11: IO27"
            const addPattern = /\[DHT\]\s*已添加DHT11:\s*(IO\d+)/;
            const addMatch = message.match(addPattern);

            if (addMatch) {
                const gpio = addMatch[1];
                addSerialLog(`DHT11 添加確認: ${gpio} 已成功添加`, 'system');

                // 檢查是否有待創建的傳感器
                if (pendingDHT11Config[gpio]) {
                    const pendingConfig = pendingDHT11Config[gpio];
                    const sensorId = pendingConfig.sensorId;

                    // 現在真正保存配置
                    sensorConfig[sensorId] = {
                        id: sensorId,
                        name: pendingConfig.name,
                        type: pendingConfig.type,
                        gpio: pendingConfig.gpio,
                        lastActive: pendingConfig.lastActive
                    };

                    // 標記GPIO為已使用
                    usedGPIOs[gpio] = sensorId;

                    // 清除待創建狀態
                    delete pendingDHT11Config[gpio];

                    // 保存配置
                    saveSensorConfig();

                    // 更新UI
                    updateSensorList();

                    // 顯示成功消息
                    showModalStatus('創建成功', 'success');

                    // 延迟 1 秒後關閉模態框
                    setTimeout(() => {
                        closeAddSensorModal();
                    }, 1000);
                }
                return;
            }

            // 匹配格式 "[DHT] 已删除DHT11: *GPIO*" 或 "[DHT] 已删除DHT11: IO27"
            const delPattern = /\[DHT\]\s*已删除DHT11:\s*(IO\d+)/;
            const delMatch = message.match(delPattern);

            if (delMatch) {
                const gpio = delMatch[1];
                addSerialLog(`DHT11 刪除確認: ${gpio} 已成功刪除`, 'system');

                // 檢查是否有待刪除的傳感器
                if (pendingDHT11Delete[gpio]) {
                    const sensorId = pendingDHT11Delete[gpio];
                    const config = sensorConfig[sensorId];

                    // 真正刪除配置
                    if (config && config.gpio) {
                        delete usedGPIOs[config.gpio];
                    }
                    delete sensorConfig[sensorId];

                    // 清除待刪除狀態
                    delete pendingDHT11Delete[gpio];

                    // 保存配置
                    saveSensorConfig();

                    // 更新UI
                    updateSensorList();

                    addSerialLog(`DHT11 傳感器 ${sensorId} 已從系統中移除`, 'system');
                }
            }
        }

        // 監聽 BLE 斷開事件
        // BLE 自動斷開連接事件處理器
        function handleBLEDisconnect() {
            if (deviceConnected) {
                deviceConnected = false;
                updateConnectButton();
                addSerialLog('系統: 設備已物理斷開連接', 'system');
                console.log('設備已物理斷開連接');

                // 清理資源
                txCharacteristic = null;
                rxCharacteristic = null;
                serialReceiveBuffer = '';
            }
        }

        // 設置 BLE 斷開連接事件監聽
        function setupBLEDisconnectHandler() {
            if (!bleDevice) return;

            // 移除舊的監聽器（防止重複）
            try {
                bleDevice.removeEventListener('gattserverdisconnected', handleBLEDisconnect);
            } catch (e) {
                // ignore
            }

            // 添加新的監聽器
            bleDevice.addEventListener('gattserverdisconnected', handleBLEDisconnect);
            console.log('BLE 斷開連接監聽已設置');
        }

        // 頁面加載時初始化
        document.addEventListener('DOMContentLoaded', function () {
            // 不需要預先初始化圖表，圖表會根據接收到的串口數據動態創建
            initializeGPIOList();
            updateConnectButton();
            loadSavedSettings();
        });

        // 顯示頁面
        function showPage(pageId) {
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');

            // 如果是首頁，重新初始化圖表
            if (pageId === 'homepage') {
                setTimeout(() => {
                    for (const chart of Object.values(charts)) {
                        chart.resize();
                    }
                }, 100);
            }
        }

        // 切換側邊欄
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const content = document.getElementById('content');
            sidebar.classList.toggle('collapsed');
            content.classList.toggle('expanded');
        }

        // 添加串口日志條目
        function addSerialLog(message, type = 'system') {
            const timestamp = new Date().toLocaleTimeString('zh-HK', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const logEntry = {
                timestamp: timestamp,
                message: message,
                type: type
            };

            serialLogHistory.push(logEntry);

            // 保持日志不超過1000條
            if (serialLogHistory.length > 1000) {
                serialLogHistory.shift();
            }

            updateSerialLogDisplay();
        }

        // 更新串口日志顯示
        function updateSerialLogDisplay() {
            const logDisplay = document.getElementById('logDisplay');
            const softLogDisplay = document.getElementById('softLogDisplay');

            // 分離軟串口日志和傳感器日志
            const softLogs = serialLogHistory.filter(entry => entry.message.includes('[soft]'));
            const sensorLogs = serialLogHistory.filter(entry => !entry.message.includes('[soft]'));

            // 更新傳感器日志顯示
            if (sensorLogs.length === 0) {
                logDisplay.innerHTML = '<div class="no-log">等待連接設備並接收數據...</div>';
            } else {
                logDisplay.innerHTML = sensorLogs.map(entry => {
                    // 將換行符(\n)和回車符(\r)轉換為HTML的<br>標籤
                    const messageWithLineBreaks = escapeHtml(entry.message)
                        .replace(/\r\n/g, '<br>')
                        .replace(/\r/g, '<br>')
                        .replace(/\n/g, '<br>');
                    return `<div class="log-entry ${entry.type}"><span class="log-timestamp">[${entry.timestamp}]</span>${messageWithLineBreaks}</div>`;
                }).join('');

                // 自動滾動到底部
                if (autoScroll) {
                    logDisplay.scrollTop = logDisplay.scrollHeight;
                }
            }

            // 更新軟串口日志顯示
            if (softLogs.length === 0) {
                softLogDisplay.innerHTML = '<div class="no-log">等待連接設備並接收數據...</div>';
            } else {
                softLogDisplay.innerHTML = softLogs.map(entry => {
                    // 將換行符(\n)和回車符(\r)轉換為HTML的<br>標籤
                    const messageWithLineBreaks = escapeHtml(entry.message)
                        .replace(/\r\n/g, '<br>')
                        .replace(/\r/g, '<br>')
                        .replace(/\n/g, '<br>');
                    return `<div class="log-entry ${entry.type}"><span class="log-timestamp">[${entry.timestamp}]</span>${messageWithLineBreaks}</div>`;
                }).join('');

                // 自動滾動到底部
                if (autoScroll) {
                    softLogDisplay.scrollTop = softLogDisplay.scrollHeight;
                }
            }
        }

        // HTML 轉義函數
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // 清空日志
        function clearSerialLog() {
            if (confirm('確定要清空所有日志嗎？')) {
                serialLogHistory = [];
                updateSerialLogDisplay();
            }
        }

        // 匯出日志
        function exportSerialLog() {
            if (serialLogHistory.length === 0) {
                alert('沒有日志可匯出');
                return;
            }

            const logText = serialLogHistory.map(entry =>
                `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
            ).join('\n');

            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `serial-log-${new Date().getTime()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 切換自動滾動
        function toggleAutoScroll() {
            autoScroll = document.getElementById('autoScrollCheckbox').checked;
            if (autoScroll) {
                const logDisplay = document.getElementById('logDisplay');
                const softLogDisplay = document.getElementById('softLogDisplay');
                logDisplay.scrollTop = logDisplay.scrollHeight;
                softLogDisplay.scrollTop = softLogDisplay.scrollHeight;
            }
        }

        // ==================== 傳感器配置功能 ====================

        // 初始化GPIO選項
        function initializeGPIOOptions() {
            const gpioSelect = document.getElementById('sensorGPIO');
            const availableGPIOs = ['IO2', 'IO32', 'IO27'];

            // 清除現有選項（保留"請選擇"）
            while (gpioSelect.children.length > 1) {
                gpioSelect.removeChild(gpioSelect.lastChild);
            }

            // 添加可用的GPIO選項（排除已使用的GPIO）
            availableGPIOs.forEach(gpio => {
                // 檢查GPIO是否被傳感器或GPIO控制臺使用
                const isUsedBySensor = usedGPIOs[gpio];
                const isUsedByGPIOControl = Object.values(gpioConfig).some(config => config.pin === gpio);

                if (!isUsedBySensor && !isUsedByGPIOControl) {
                    const option = document.createElement('option');
                    option.value = gpio;
                    option.textContent = gpio;
                    gpioSelect.appendChild(option);
                }
            });
        }

        // 打開新增傳感器模態框
        function openAddSensorModal() {
            initializeGPIOOptions();
            clearModalForm();
            document.getElementById('addSensorModal').classList.add('show');
        }

        // 關閉新增傳感器模態框
        function closeAddSensorModal() {
            // 立即隱藏模態框
            document.getElementById('addSensorModal').classList.remove('show');
            // 清除表單數據
            clearModalForm();
        }

        // 清除模態框表單
        function clearModalForm() {
            document.getElementById('sensorName').value = '';
            document.getElementById('sensorType').value = '';
            document.getElementById('sensorGPIO').value = '';
            document.getElementById('nameError').textContent = '';
            document.getElementById('typeError').textContent = '';
            document.getElementById('gpioError').textContent = '';
            clearModalStatus();
        }

        // 清除模態框狀態消息
        function clearModalStatus() {
            const statusDiv = document.getElementById('modalStatus');
            statusDiv.textContent = '';
            statusDiv.classList.remove('show', 'success', 'error');
        }

        // 顯示模態框狀態消息
        function showModalStatus(message, type) {
            const statusDiv = document.getElementById('modalStatus');
            statusDiv.textContent = message;
            statusDiv.classList.add('show', type);
        }

        // 驗證和添加傳感器
        function confirmAddSensor() {
            const name = document.getElementById('sensorName').value.trim();
            const type = document.getElementById('sensorType').value;
            const gpio = document.getElementById('sensorGPIO').value;

            // 清除錯誤消息
            document.getElementById('nameError').textContent = '';
            document.getElementById('typeError').textContent = '';
            document.getElementById('gpioError').textContent = '';

            let hasError = false;
            let errorMessage = '';

            // 驗證傳感器名稱
            if (!name) {
                document.getElementById('nameError').textContent = '傳感器名稱不能為空';
                errorMessage = '缺少傳感器名稱';
                hasError = true;
            }

            // 驗證傳感器種類
            if (!type) {
                document.getElementById('typeError').textContent = '請選擇傳感器種類';
                if (!errorMessage) errorMessage = '未選擇傳感器種類';
                hasError = true;
            }

            // 驗證GPIO
            if (!gpio) {
                document.getElementById('gpioError').textContent = '請選擇GPIO';
                if (!errorMessage) errorMessage = '未選擇GPIO';
                hasError = true;
            }

            // 驗證GPIO是否已被使用
            if (gpio && usedGPIOs[gpio]) {
                document.getElementById('gpioError').textContent = '此GPIO已被其他傳感器使用，請選擇其他GPIO';
                if (!errorMessage) errorMessage = 'GPIO已被使用';
                hasError = true;
            }

            if (hasError) {
                showModalStatus(errorMessage, 'error');
                return;
            }

            // 如果是DHT11傳感器
            if (type === 'DHT11') {
                if (!deviceConnected) {
                    showModalStatus('錯誤: 設備未連接', 'error');
                    return;
                }

                // 創建臨時傳感器對象（不保存到sensorConfig）
                const sensorId = 'sensor_' + (++sensorIdCounter);
                const now = new Date();
                const lastActive = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                // 保存到待創建配置
                pendingDHT11Config[gpio] = {
                    sensorId: sensorId,
                    name: name,
                    type: type,
                    gpio: gpio,
                    lastActive: lastActive
                };

                // 不占用GPIO，只發送命令
                showModalStatus('創建中...', 'system');
                sendDHT11AddCommand(gpio);
            } else {
                // 非DHT11傳感器的処理邏輯保持不變
                // 創建傳感器對象
                const sensorId = 'sensor_' + (++sensorIdCounter);
                const now = new Date();
                const lastActive = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                sensorConfig[sensorId] = {
                    id: sensorId,
                    name: name,
                    type: type,
                    gpio: gpio,
                    lastActive: lastActive
                };

                // 標記GPIO為已使用
                usedGPIOs[gpio] = sensorId;

                // 保存配置到本地存儲
                saveSensorConfig();

                // 更新UI
                updateSensorList();

                // 顯示成功消息
                showModalStatus('創建成功', 'success');

                // 延迟 1 秒後關閉模態框
                setTimeout(() => {
                    closeAddSensorModal();
                }, 1000);
            }
        }

        // 更新傳感器列表
        function updateSensorList() {
            const tbody = document.getElementById('sensorListBody');

            if (Object.keys(sensorConfig).length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="no-sensor-message">暫無傳感器，請點擊"新增+"按鈕添加傳感器</td></tr>';
                return;
            }

            tbody.innerHTML = '';

            for (const [sensorId, config] of Object.entries(sensorConfig)) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(config.name)}</td>
                    <td>${escapeHtml(config.type)}</td>
                    <td>${escapeHtml(config.gpio)}</td>
                    <td>${escapeHtml(config.lastActive)}</td>
                    <td><button class="btn-delete-row" onclick="deleteSensor('${sensorId}')">刪除</button></td>
                `;
                tbody.appendChild(row);
            }
        }

        // 刪除單個傳感器
        function deleteSensor(sensorId) {
            if (!confirm('確定要刪除此傳感器嗎？')) {
                return;
            }

            const config = sensorConfig[sensorId];

            // 如果是DHT11傳感器
            if (config && config.type === 'DHT11') {
                if (!deviceConnected) {
                    alert('設備未連接，無法刪除DHT11傳感器');
                    return;
                }

                // 保存待刪除狀態
                pendingDHT11Delete[config.gpio] = sensorId;

                // 發送刪除命令
                sendDHT11DeleteCommand(config.gpio);
            } else {
                // 非DHT11傳感器的删除邏輯保持不變
                if (config && config.gpio) {
                    delete usedGPIOs[config.gpio];
                }
                delete sensorConfig[sensorId];

                updateSensorList();
                saveSensorConfig();
            }
        }

        // 保存傳感器配置到本地存儲
        function saveSensorConfig() {
            localStorage.setItem('sensorConfig', JSON.stringify(sensorConfig));
            localStorage.setItem('usedGPIOs', JSON.stringify(usedGPIOs));
            localStorage.setItem('sensorIdCounter', sensorIdCounter.toString());
        }

        // 從本地存儲加載傳感器配置
        function loadSensorConfig() {
            const saved = localStorage.getItem('sensorConfig');
            if (saved) {
                sensorConfig = JSON.parse(saved);
            }

            const savedGPIOs = localStorage.getItem('usedGPIOs');
            if (savedGPIOs) {
                usedGPIOs = JSON.parse(savedGPIOs);
            }

            const savedCounter = localStorage.getItem('sensorIdCounter');
            if (savedCounter) {
                sensorIdCounter = parseInt(savedCounter);
            }

            updateSensorList();
        }

        // 頁面初始化時加載傳感器配置
        window.addEventListener('load', function () {
            loadSensorConfig();
        });

        // 确保配置在初始化时加载
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadSensorConfig);
        } else {
            loadSensorConfig();
        }

        // ==================== GPIO 控制臺功能 ====================

        // 獲取可用的GPIO選項（排除已使用的GPIO）
        function getAvailableGPIOPins() {
            const allGPIOs = ['IO2', 'IO27', 'IO32'];
            const availableGPIOs = allGPIOs.filter(gpio => !usedGPIOs[gpio] && !Object.values(gpioConfig).some(config => config.pin === gpio));
            return availableGPIOs;
        }

        // 初始化GPIO選項（GPIO控制臺）
        function initializeGPIOPinOptions() {
            const gpioSelect = document.getElementById('gpioPin');
            const availableGPIOs = getAvailableGPIOPins();

            // 清除現有選項（保留"請選擇"）
            while (gpioSelect.children.length > 1) {
                gpioSelect.removeChild(gpioSelect.lastChild);
            }

            // 添加可用的GPIO選項
            availableGPIOs.forEach(gpio => {
                const option = document.createElement('option');
                option.value = gpio;
                option.textContent = gpio;
                gpioSelect.appendChild(option);
            });
        }

        // 打開新增GPIO模態框
        function openAddGPIOModal() {
            initializeGPIOPinOptions();
            clearGPIOModalForm();
            document.getElementById('addGPIOModal').classList.add('show');
        }

        // 關閉新增GPIO模態框
        function closeAddGPIOModal() {
            document.getElementById('addGPIOModal').classList.remove('show');
            clearGPIOModalForm();
        }

        // 清除GPIO模態框表單
        function clearGPIOModalForm() {
            document.getElementById('gpioName').value = '';
            document.getElementById('gpioPin').value = '';
            document.getElementById('gpioMode').value = '';
            document.getElementById('gpioNameError').textContent = '';
            document.getElementById('gpioPinError').textContent = '';
            document.getElementById('gpioModeError').textContent = '';
            clearGPIOModalStatus();
        }

        // 清除GPIO模態框狀態消息
        function clearGPIOModalStatus() {
            const statusDiv = document.getElementById('gpioModalStatus');
            statusDiv.textContent = '';
            statusDiv.classList.remove('show', 'success', 'error');
        }

        // 顯示GPIO模態框狀態消息
        function showGPIOModalStatus(message, type) {
            const statusDiv = document.getElementById('gpioModalStatus');
            statusDiv.textContent = message;
            statusDiv.classList.add('show', type);
        }

        // 驗證和添加GPIO
        function confirmAddGPIO() {
            const name = document.getElementById('gpioName').value.trim();
            const pin = document.getElementById('gpioPin').value;
            const mode = document.getElementById('gpioMode').value;

            // 清除錯誤消息
            document.getElementById('gpioNameError').textContent = '';
            document.getElementById('gpioPinError').textContent = '';
            document.getElementById('gpioModeError').textContent = '';

            let hasError = false;
            let errorMessage = '';

            // 驗證GPIO名稱
            if (!name) {
                document.getElementById('gpioNameError').textContent = 'GPIO名稱不能為空';
                errorMessage = '缺少GPIO名稱';
                hasError = true;
            }

            // 驗證GPIO Pin
            if (!pin) {
                document.getElementById('gpioPinError').textContent = '請選擇GPIO Pin';
                if (!errorMessage) errorMessage = '未選擇GPIO Pin';
                hasError = true;
            }

            // 驗證GPIO Pin是否已被使用
            if (pin && (usedGPIOs[pin] || Object.values(gpioConfig).some(config => config.pin === pin))) {
                document.getElementById('gpioPinError').textContent = '此GPIO已被使用，請選擇其他GPIO';
                if (!errorMessage) errorMessage = 'GPIO已被使用';
                hasError = true;
            }

            // 驗證輸出模式
            if (!mode) {
                document.getElementById('gpioModeError').textContent = '請選擇輸出模式';
                if (!errorMessage) errorMessage = '未選擇輸出模式';
                hasError = true;
            }

            if (hasError) {
                showGPIOModalStatus(errorMessage, 'error');
                return;
            }

            // 創建GPIO對象
            const gpioId = 'gpio_' + (++gpioIdCounter);

            gpioConfig[gpioId] = {
                id: gpioId,
                name: name,
                pin: pin,
                mode: mode,
                status: mode === 'digital' ? 'LOW' : '0'
            };

            // 保存配置到本地存儲
            saveGPIOConfig();

            // 更新UI（GPIO配置列表和首頁GPIO狀態）
            updateGPIOConfigList();

            // 顯示成功消息
            showGPIOModalStatus('創建成功', 'success');

            // 延迟 1 秒後關閉模態框
            setTimeout(() => {
                closeAddGPIOModal();
            }, 1000);
        }

        // 更新GPIO配置列表（GPIO控制臺頁面）
        function updateGPIOConfigList() {
            const tbody = document.getElementById('gpioListBody');

            if (Object.keys(gpioConfig).length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="no-sensor-message">暫無GPIO配置，請點擊"新增+"按鈕添加GPIO</td></tr>';
                return;
            }

            tbody.innerHTML = '';

            for (const [gpioId, config] of Object.entries(gpioConfig)) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(config.name)}</td>
                    <td>${escapeHtml(config.pin)}</td>
                    <td>${config.mode === 'digital' ? 'Digital' : 'Analog'}</td>
                    <td>${escapeHtml(config.status)}</td>
                    <td><button class="btn-delete-row" onclick="deleteGPIO('${gpioId}')">刪除</button></td>
                `;
                tbody.appendChild(row);
            }

            // 同時更新首頁的GPIO狀態
            initializeGPIOList();
        }

        // 刪除單個GPIO
        function deleteGPIO(gpioId) {
            if (!confirm('確定要刪除此GPIO嗎？')) {
                return;
            }

            delete gpioConfig[gpioId];
            saveGPIOConfig();
            updateGPIOConfigList();
        }

        // 保存GPIO配置到本地存儲
        function saveGPIOConfig() {
            localStorage.setItem('gpioConfig', JSON.stringify(gpioConfig));
            localStorage.setItem('gpioIdCounter', gpioIdCounter.toString());
        }

        // 從本地存儲加載GPIO配置
        function loadGPIOConfig() {
            const saved = localStorage.getItem('gpioConfig');
            if (saved) {
                gpioConfig = JSON.parse(saved);
            }

            const savedCounter = localStorage.getItem('gpioIdCounter');
            if (savedCounter) {
                gpioIdCounter = parseInt(savedCounter);
            }

            updateGPIOConfigList();
            initializeGPIOList();
        }

        // 頁面初始化時加載GPIO配置
        window.addEventListener('load', function () {
            loadGPIOConfig();
        });

        // 确保GPIO配置在初始化时加载
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadGPIOConfig);
        } else {
            loadGPIOConfig();
        }

        // ==================== 重置設置功能 ====================

        // ==================== WiFi 設置功能 ====================

        // 顯示WiFi設置回復消息
        function showWiFiResponse(message, type = 'info') {
            const responseBox = document.getElementById('wifiResponseBox');
            responseBox.textContent = message;
            responseBox.className = `wifi-response-box show ${type}`;
            if (type === 'error') {
                setTimeout(() => {
                    responseBox.classList.remove('show');
                }, 10000);
            }
        }

        // 清除WiFi輸入框中的錯誤提示
        function clearWiFiErrors() {
            document.getElementById('wifiSSIDError').textContent = '';
            document.getElementById('wifiPasswordError').textContent = '';
        }

        // 通過藍牙發送WiFi設置命令
        async function sendWiFiCommand(ssid, password) {
            if (!deviceConnected || !rxCharacteristic) {
                showWiFiResponse('請先連接設備', 'error');
                return false;
            }

            try {
                const encoder = new TextEncoder();

                // 發送SSID命令: [set][SSID]=*ssid*
                const ssidCommand = `[set][SSID]=${ssid}`;
                await rxCharacteristic.writeValue(encoder.encode(ssidCommand + '\n'));
                addSerialLog(`發送WiFi SSID命令: ${ssidCommand}`, 'send');

                // 等待一小段時間再發送密碼
                await new Promise(resolve => setTimeout(resolve, 100));

                // 發送密碼命令: [set][PW]=*password*
                const pwCommand = `[set][PW]=${password}`;
                await rxCharacteristic.writeValue(encoder.encode(pwCommand + '\n'));
                addSerialLog(`發送WiFi密碼命令: ${pwCommand}`, 'send');

                return true;
            } catch (error) {
                console.error('發送WiFi命令失敗:', error);
                addSerialLog('錯誤: 發送WiFi命令失敗 - ' + error.message, 'error');
                return false;
            }
        }

        // 保存WiFi設置
        async function saveWiFiSettings() {
            clearWiFiErrors();

            const ssid = document.getElementById('wifiSSID').value.trim();
            const password = document.getElementById('wifiPassword').value.trim();

            let hasError = false;

            // 驗證SSID
            if (!ssid) {
                document.getElementById('wifiSSIDError').textContent = '請輸入WiFi SSID';
                hasError = true;
            }

            // 驗證密碼
            if (!password) {
                document.getElementById('wifiPasswordError').textContent = '請輸入WiFi密碼';
                hasError = true;
            }

            if (hasError) {
                showWiFiResponse('請填寫所有必填字段', 'error');
                return;
            }

            // 通過藍牙發送命令
            const success = await sendWiFiCommand(ssid, password);

            if (success) {
                // 保存到本地存儲
                const wifiConfig = {
                    ssid: ssid,
                    password: password,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('wifiConfig', JSON.stringify(wifiConfig));
                showWiFiResponse('WiFi 設置已發送並保存', 'success');
            } else {
                showWiFiResponse('WiFi 設置發送失敗，請檢查設備連接', 'error');
            }
        }

        // 清除WiFi設置
        function clearWiFiSettings() {
            document.getElementById('wifiSSID').value = '';
            document.getElementById('wifiPassword').value = '';
            clearWiFiErrors();
            localStorage.removeItem('wifiConfig');
            showWiFiResponse('WiFi 設置已清除', 'info');
            addSerialLog('WiFi 設置已清除 (本地)', 'system');
        }

        // 連接WiFi
        async function connectWiFi() {
            if (!deviceConnected || !rxCharacteristic) {
                showWiFiResponse('請先連接設備', 'error');
                return;
            }

            try {
                const encoder = new TextEncoder();
                const command = '[conn][wifi]=5';
                await rxCharacteristic.writeValue(encoder.encode(command + '\n'));
                addSerialLog(`發送WiFi連接命令: ${command}`, 'send');
                showWiFiResponse('WiFi 連接命令已發送', 'success');
            } catch (error) {
                console.error('發送WiFi連接命令失敗:', error);
                addSerialLog('錯誤: 發送WiFi連接命令失敗 - ' + error.message, 'error');
                showWiFiResponse('WiFi 連接命令發送失敗', 'error');
            }
        }

        // 保存WiFi設置

        // OneNET 連接功能已移除。保留輸入框和本地保存功能（不發起網絡請求）。
        function showOneNETResponse(message, type = 'info') {
            const responseBox = document.getElementById('onenetResponseBox');
            responseBox.textContent = message;
            responseBox.className = `onenet-response-box show ${type}`;
            if (type === 'error') {
                setTimeout(() => {
                    responseBox.classList.remove('show');
                }, 10000);
            }
        }

        // 保存 OneNET 設置到本地（不嘗試連接）
        async function saveOneNETSettings() {
            const userID = document.getElementById('userID').value.trim();
            const userAccessKey = document.getElementById('userAccessKey').value.trim();
            const productID = document.getElementById('productID').value.trim();
            const deviceName = document.getElementById('deviceName').value.trim();
            const deviceKey = document.getElementById('deviceKey').value.trim();

            const required = [];
            if (!userID) required.push('User_ID');
            if (!userAccessKey) required.push('User_AccessKey');
            if (!productID) required.push('Product ID');
            if (!deviceName) required.push('Device Name');
            if (!deviceKey) required.push('Device Key');

            if (required.length > 0) {
                showOneNETResponse('請填寫以下必填字段：' + required.join(', '), 'error');
                return;
            }

            // 嘗試通過藍牙發送OneNET設置命令
            let sentViaBluetoooth = false;
            if (deviceConnected && rxCharacteristic) {
                try {
                    const encoder = new TextEncoder();

                    // 發送Product ID命令: [set][PID]=*product id*
                    const pidCommand = `[set][PID]=${productID}`;
                    await rxCharacteristic.writeValue(encoder.encode(pidCommand + '\n'));
                    addSerialLog(`發送OneNET Product ID命令: ${pidCommand}`, 'send');

                    // 等待一小段時間
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // 發送Device Name命令: [set][DID]=*device name*
                    const didCommand = `[set][DID]=${deviceName}`;
                    await rxCharacteristic.writeValue(encoder.encode(didCommand + '\n'));
                    addSerialLog(`發送OneNET Device Name命令: ${didCommand}`, 'send');

                    // 等待一小段時間
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // 發送Device Key命令: [set][DPW]=*device key*
                    const dpwCommand = `[set][DPW]=${deviceKey}`;
                    await rxCharacteristic.writeValue(encoder.encode(dpwCommand + '\n'));
                    addSerialLog(`發送OneNET Device Key命令: ${dpwCommand}`, 'send');

                    sentViaBluetoooth = true;
                } catch (error) {
                    console.error('通過藍牙發送OneNET設置失敗:', error);
                    addSerialLog('警告: 通過藍牙發送OneNET設置失敗 - ' + error.message, 'error');
                }
            }

            const oneNetConfig = {
                userID, userAccessKey, productID, deviceName, deviceKey, timestamp: new Date().toISOString()
            };
            localStorage.setItem('oneNetConfig', JSON.stringify(oneNetConfig));

            if (sentViaBluetoooth) {
                showOneNETResponse('OneNET 設置已保存並通過藍牙發送到設備', 'success');
            } else {
                showOneNETResponse('OneNET 設置已保存 (未能發送到設備，請檢查設備連接)', 'success');
            }
            addSerialLog('OneNET 設置已保存 (本地)', 'system');
        }

        // 連接OneNET
        async function connectOneNET() {
            if (!deviceConnected || !rxCharacteristic) {
                showOneNETResponse('請先連接設備', 'error');
                return;
            }

            try {
                const encoder = new TextEncoder();
                const command = '[conn][onenet]';
                await rxCharacteristic.writeValue(encoder.encode(command + '\n'));
                addSerialLog(`發送OneNET連接命令: ${command}`, 'send');
                showOneNETResponse('OneNET 連接命令已發送', 'success');
            } catch (error) {
                console.error('發送OneNET連接命令失敗:', error);
                addSerialLog('錯誤: 發送OneNET連接命令失敗 - ' + error.message, 'error');
                showOneNETResponse('OneNET 連接命令發送失敗', 'error');
            }
        }

        // 清除本地保存的 OneNET 設置（僅本地操作）
        function clearOneNETSettings() {
            localStorage.removeItem('oneNetConfig');
            document.getElementById('userID').value = '';
            document.getElementById('userAccessKey').value = '';
            document.getElementById('productID').value = '';
            document.getElementById('deviceName').value = '';
            document.getElementById('deviceKey').value = '';
            document.getElementById('imei').value = '';
            document.getElementById('imsi').value = '';
            showOneNETResponse('OneNET 設置已清除', 'info');
            addSerialLog('OneNET 設置已清除 (本地)', 'system');
        }

        // 加載已保存的設置
        function loadSavedSettings() {
            // 加載WiFi設置
            const savedWiFiConfig = localStorage.getItem('wifiConfig');
            if (savedWiFiConfig) {
                try {
                    const wifiConfig = JSON.parse(savedWiFiConfig);
                    document.getElementById('wifiSSID').value = wifiConfig.ssid || '';
                    document.getElementById('wifiPassword').value = wifiConfig.password || '';
                } catch (e) {
                    console.error('Failed to load WiFi config:', e);
                }
            }

            // 加載OneNET設置
            const savedOneNetConfig = localStorage.getItem('oneNetConfig');
            if (savedOneNetConfig) {
                try {
                    const oneNetConfig = JSON.parse(savedOneNetConfig);
                    document.getElementById('userID').value = oneNetConfig.userID || '';
                    document.getElementById('userAccessKey').value = oneNetConfig.userAccessKey || '';
                    document.getElementById('productID').value = oneNetConfig.productID || '';
                    document.getElementById('deviceName').value = oneNetConfig.deviceName || '';
                    document.getElementById('deviceKey').value = oneNetConfig.deviceKey || '';
                    document.getElementById('imei').value = oneNetConfig.imei || '';
                    document.getElementById('imsi').value = oneNetConfig.imsi || '';
                } catch (e) {
                    console.error('Failed to load OneNET config:', e);
                }
            }
        }

        // 重置所有傳感器設置和GPIO選項
        function resetAllSettings() {
            // 二次確認，防止誤操作
            if (!confirm('確定要重置所有傳感器設置和GPIO選項嗎？此操作無法撤銷！')) {
                return;
            }

            if (!confirm('這是最後的確認：所有數據將被永久刪除。真的要繼續嗎？')) {
                return;
            }

            // 清除所有配置
            sensorConfig = {};
            gpioConfig = {};
            gpioConfirmStatus = {};
            usedGPIOs = {};
            sensorIdCounter = 0;
            gpioIdCounter = 0;

            // 清除本地存儲
            localStorage.removeItem('sensorConfig');
            localStorage.removeItem('usedGPIOs');
            localStorage.removeItem('sensorIdCounter');
            localStorage.removeItem('gpioConfig');
            localStorage.removeItem('gpioIdCounter');

            // 重新初始化UI
            updateSensorList();
            updateGPIOConfigList();
            initializeGPIOList();
            initializeGPIOOptions();

            // 顯示成功提示
            alert('已成功重置所有傳感器設置和GPIO選項。');
        }
    </script>
</body>

</html>