<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMU 數據可視化</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        canvas { max-width: 600px; margin: 20px auto; }
        #serialMonitor { width: 80%; height: 150px; margin: 10px auto; }
        button { margin: 5px; padding: 10px; }
        #status { color: red; }
    </style>
</head>
<body>
    <h1>IMU 數據可視化</h1>
    <button onclick="connectSerial()">連接串口</button>
    <button onclick="disconnectSerial()">斷開連接</button>
    <p id="status">未連接</p>
    <p>串口設置: 115200 baud</p>
    <p>數據格式範例:</p>
    <pre>
X Accele:0.514892578125
Y Gyrosc:3.36641221374046
    </pre>
    <h2>加速度 (m/s²)</h2>
    <canvas id="accelChart"></canvas>
    <h2>陀螺儀 (radians/s)</h2>
    <canvas id="gyroChart"></canvas>
    <h2>串口輸入監視器</h2>
    <textarea id="serialMonitor" readonly></textarea><br>
    <button onclick="clearMonitor()">清除內容</button>

    <script>
        let port;
        let reader;
        let accelChart, gyroChart;
        let accelData = [];
        let gyroData = [];
        const maxDataPoints = 50; // Max points to display on chart
        const avgWindow = 5; // Number of readings to average
        let accelBuffer = [];
        let gyroBuffer = [];

        // Initialize Charts
        function initCharts() {
            accelChart = new Chart(document.getElementById('accelChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'X 加速度 (m/s²)',
                        data: [],
                        borderColor: 'blue',
                        fill: false
                    }]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: '時間' } },
                        y: { title: { display: true, text: '加速度 (m/s²)' } }
                    }
                }
            });

            gyroChart = new Chart(document.getElementById('gyroChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Y 陀螺儀 (radians/s)',
                        data: [],
                        borderColor: 'green',
                        fill: false
                    }]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: '時間' } },
                        y: { title: { display: true, text: '角速度 (radians/s)' } }
                    }
                }
            });
        }

        // Parse Serial Data
        function parseSerialData(data) {
            const lines = data.split('\n');
            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('X Accele:')) {
                    const value = parseFloat(line.replace('X Accele:', ''));
                    if (!isNaN(value)) {
                        accelBuffer.push(value);
                        if (accelBuffer.length >= avgWindow) {
                            const avg = accelBuffer.reduce((sum, val) => sum + val, 0) / avgWindow;
                            updateChart(accelChart, avg);
                            accelBuffer.shift(); // Remove oldest value
                        }
                    }
                } else if (line.startsWith('Y Gyrosc:')) {
                    const value = parseFloat(line.replace('Y Gyrosc:', ''));
                    if (!isNaN(value)) {
                        gyroBuffer.push(value);
                        if (gyroBuffer.length >= avgWindow) {
                            const avg = gyroBuffer.reduce((sum, val) => sum + val, 0) / avgWindow;
                            updateChart(gyroChart, avg);
                            gyroBuffer.shift(); // Remove oldest value
                        }
                    }
                }
                document.getElementById('serialMonitor').value += line + '\n';
            });
        }

        // Update Chart with Averaged Data
        function updateChart(chart, value) {
            const now = new Date().toLocaleTimeString();
            chart.data.labels.push(now);
            chart.data.datasets[0].data.push(value);

            if (chart.data.labels.length > maxDataPoints) {
                chart.data.labels.shift();
                chart.data.datasets[0].data.shift();
            }
            chart.update();
        }

        // Connect to Serial Port
        async function connectSerial() {
            try {
                port = await navigator.serial.requestPort({});
                await port.open({ baudRate: 115200 });
                document.getElementById('status').textContent = '已連接';
                document.getElementById('status').style.color = 'green';
                reader = port.readable.getReader();
                readSerial();
            } catch (error) {
                document.getElementById('status').textContent = '連接失敗: ' + error;
            }
        }

        // Disconnect Serial Port
        async function disconnectSerial() {
            if (reader) {
                await reader.cancel();
                reader.releaseLock();
                await port.close();
                document.getElementById('status').textContent = '未連接';
                document.getElementById('status').style.color = 'red';
            }
        }

        // Read Serial Data
        async function readSerial() {
            while (port.readable) {
                try {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const text = new TextDecoder().decode(value);
                    parseSerialData(text);
                } catch (error) {
                    document.getElementById('status').textContent = '讀取錯誤: ' + error;
                    break;
                }
            }
        }

        // Clear Serial Monitor
        function clearMonitor() {
            document.getElementById('serialMonitor').value = '';
        }

        // Initialize on Page Load
        window.onload = initCharts;
    </script>
</body>
</html>